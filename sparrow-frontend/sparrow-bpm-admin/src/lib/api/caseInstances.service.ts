/**
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable } from 'rxjs';

import { CaseAdHocFragmentList } from '../model/caseAdHocFragmentList';
import { CaseCommentList } from '../model/caseCommentList';
import { CaseDefinition } from '../model/caseDefinition';
import { CaseDefinitionList } from '../model/caseDefinitionList';
import { CaseInstance } from '../model/caseInstance';
import { CaseInstanceList } from '../model/caseInstanceList';
import { CaseMilestoneList } from '../model/caseMilestoneList';
import { CaseRoleAssignmentList } from '../model/caseRoleAssignmentList';
import { CaseStageList } from '../model/caseStageList';
import { NodeInstanceList } from '../model/nodeInstanceList';
import { ProcessInstanceList } from '../model/processInstanceList';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class CaseInstancesService {

    protected basePath = 'https://localhost/bpm/rest';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Adds a comment to a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param body actual content of the comment to be added as String
     * @param author optional user id to be used instead of authenticated user - only when bypass authenticated user is enabled
     * @param restrictedTo optional role name(s) that given comment should be restricted to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addComment(containerId: string, caseId: string, body: string, author?: string, restrictedTo?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public addComment(containerId: string, caseId: string, body: string, author?: string, restrictedTo?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public addComment(containerId: string, caseId: string, body: string, author?: string, restrictedTo?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public addComment(containerId: string, caseId: string, body: string, author?: string, restrictedTo?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling addComment.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling addComment.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addComment.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (author !== undefined && author !== null) {
            queryParameters = queryParameters.set('author', <any>author);
        }
        if (restrictedTo) {
            restrictedTo.forEach((element) => {
                queryParameters = queryParameters.append('restrictedTo', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/comments`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Adds dynamic subprocess identified by process id to stage within case instance
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param caseStageId identifier of the stage within case instance where dynamic subprocess should be added
     * @param processId process id of the subprocess to be added
     * @param body data for dynamic subprocess
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addDynamicProcessToCase(containerId: string, caseId: string, caseStageId: string, processId: string, body: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public addDynamicProcessToCase(containerId: string, caseId: string, caseStageId: string, processId: string, body: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public addDynamicProcessToCase(containerId: string, caseId: string, caseStageId: string, processId: string, body: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public addDynamicProcessToCase(containerId: string, caseId: string, caseStageId: string, processId: string, body: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling addDynamicProcessToCase.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling addDynamicProcessToCase.');
        }

        if (caseStageId === null || caseStageId === undefined) {
            throw new Error('Required parameter caseStageId was null or undefined when calling addDynamicProcessToCase.');
        }

        if (processId === null || processId === undefined) {
            throw new Error('Required parameter processId was null or undefined when calling addDynamicProcessToCase.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addDynamicProcessToCase.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/stages/${encodeURIComponent(String(caseStageId))}/processes/${encodeURIComponent(String(processId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Adds a dynamic subprocess to a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param processId process id of the subprocess to be added
     * @param body data for dynamic subprocess
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addDynamicProcessToCase1(containerId: string, caseId: string, processId: string, body: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public addDynamicProcessToCase1(containerId: string, caseId: string, processId: string, body: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public addDynamicProcessToCase1(containerId: string, caseId: string, processId: string, body: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public addDynamicProcessToCase1(containerId: string, caseId: string, processId: string, body: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling addDynamicProcessToCase1.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling addDynamicProcessToCase1.');
        }

        if (processId === null || processId === undefined) {
            throw new Error('Required parameter processId was null or undefined when calling addDynamicProcessToCase1.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addDynamicProcessToCase1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/processes/${encodeURIComponent(String(processId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Adds a dynamic user task or service task to the specified stage in a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param caseStageId identifier of the stage within case instance where dynamic task should be added
     * @param body data for dynamic task (it represents task specification that drives the selection of the type of task)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addDynamicTaskToCase(containerId: string, caseId: string, caseStageId: string, body: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public addDynamicTaskToCase(containerId: string, caseId: string, caseStageId: string, body: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public addDynamicTaskToCase(containerId: string, caseId: string, caseStageId: string, body: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public addDynamicTaskToCase(containerId: string, caseId: string, caseStageId: string, body: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling addDynamicTaskToCase.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling addDynamicTaskToCase.');
        }

        if (caseStageId === null || caseStageId === undefined) {
            throw new Error('Required parameter caseStageId was null or undefined when calling addDynamicTaskToCase.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addDynamicTaskToCase.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/stages/${encodeURIComponent(String(caseStageId))}/tasks`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Adds a dynamic user task or service task to the specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param body data for dynamic task (it represents task specification that drives the selection of the type of task)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addDynamicTaskToCase1(containerId: string, caseId: string, body: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public addDynamicTaskToCase1(containerId: string, caseId: string, body: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public addDynamicTaskToCase1(containerId: string, caseId: string, body: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public addDynamicTaskToCase1(containerId: string, caseId: string, body: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling addDynamicTaskToCase1.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling addDynamicTaskToCase1.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addDynamicTaskToCase1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/tasks`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Assigns a specified case role to a specified user and group for a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param caseRoleName name of the case role the assignment should be set
     * @param user user to be aded to case role for given case instance
     * @param group group to be aded to case role for given case instance
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addRoleAssignment(containerId: string, caseId: string, caseRoleName: string, user: string, group: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public addRoleAssignment(containerId: string, caseId: string, caseRoleName: string, user: string, group: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public addRoleAssignment(containerId: string, caseId: string, caseRoleName: string, user: string, group: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public addRoleAssignment(containerId: string, caseId: string, caseRoleName: string, user: string, group: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling addRoleAssignment.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling addRoleAssignment.');
        }

        if (caseRoleName === null || caseRoleName === undefined) {
            throw new Error('Required parameter caseRoleName was null or undefined when calling addRoleAssignment.');
        }

        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling addRoleAssignment.');
        }

        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling addRoleAssignment.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }
        if (group !== undefined && group !== null) {
            queryParameters = queryParameters.set('group', <any>group);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.put<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/roles/${encodeURIComponent(String(caseRoleName))}`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Aborts or permanently destroys a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param destroy allows to destroy (permanently) case instance as part of the cancel operation, defaults to false
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cancelCaseInstance(containerId: string, caseId: string, destroy?: boolean, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public cancelCaseInstance(containerId: string, caseId: string, destroy?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public cancelCaseInstance(containerId: string, caseId: string, destroy?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public cancelCaseInstance(containerId: string, caseId: string, destroy?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling cancelCaseInstance.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling cancelCaseInstance.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (destroy !== undefined && destroy !== null) {
            queryParameters = queryParameters.set('destroy', <any>destroy);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Closes a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param body optional comment when closing a case instance as String
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public closeCaseInstance(containerId: string, caseId: string, body?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public closeCaseInstance(containerId: string, caseId: string, body?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public closeCaseInstance(containerId: string, caseId: string, body?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public closeCaseInstance(containerId: string, caseId: string, body?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling closeCaseInstance.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling closeCaseInstance.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes one or more specified case file data items from a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param dataId one or more names of the data items to be removed from case file
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCaseInstanceData(containerId: string, caseId: string, dataId: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteCaseInstanceData(containerId: string, caseId: string, dataId: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteCaseInstanceData(containerId: string, caseId: string, dataId: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteCaseInstanceData(containerId: string, caseId: string, dataId: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling deleteCaseInstanceData.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling deleteCaseInstanceData.');
        }

        if (dataId === null || dataId === undefined) {
            throw new Error('Required parameter dataId was null or undefined when calling deleteCaseInstanceData.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (dataId) {
            dataId.forEach((element) => {
                queryParameters = queryParameters.append('dataId', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/caseFile`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns case definitions in a specified KIE container.
     *
     * @param containerId container id that should be used to filter case definitions
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCaseDefinitionsByContainer(containerId: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<CaseDefinitionList>;
    public getCaseDefinitionsByContainer(containerId: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CaseDefinitionList>>;
    public getCaseDefinitionsByContainer(containerId: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CaseDefinitionList>>;
    public getCaseDefinitionsByContainer(containerId: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getCaseDefinitionsByContainer.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CaseDefinitionList>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/definitions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns information about a specified case definition.
     *
     * @param containerId container id that should be used to filter case definitions
     * @param caseDefId case definition id that should be loaded
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCaseDefinitionsByDefinition(containerId: string, caseDefId: string, observe?: 'body', reportProgress?: boolean): Observable<CaseDefinition>;
    public getCaseDefinitionsByDefinition(containerId: string, caseDefId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CaseDefinition>>;
    public getCaseDefinitionsByDefinition(containerId: string, caseDefId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CaseDefinition>>;
    public getCaseDefinitionsByDefinition(containerId: string, caseDefId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getCaseDefinitionsByDefinition.');
        }

        if (caseDefId === null || caseDefId === undefined) {
            throw new Error('Required parameter caseDefId was null or undefined when calling getCaseDefinitionsByDefinition.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CaseDefinition>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/definitions/${encodeURIComponent(String(caseDefId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns information about a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param withData optional flag to load data when loading case instance
     * @param withRoles optional flag to load roles when loading case instance
     * @param withMilestones optional flag to load milestones when loading case instance
     * @param withStages optional flag to load stages when loading case instance
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCaseInstance(containerId: string, caseId: string, withData?: boolean, withRoles?: boolean, withMilestones?: boolean, withStages?: boolean, observe?: 'body', reportProgress?: boolean): Observable<CaseInstance>;
    public getCaseInstance(containerId: string, caseId: string, withData?: boolean, withRoles?: boolean, withMilestones?: boolean, withStages?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CaseInstance>>;
    public getCaseInstance(containerId: string, caseId: string, withData?: boolean, withRoles?: boolean, withMilestones?: boolean, withStages?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CaseInstance>>;
    public getCaseInstance(containerId: string, caseId: string, withData?: boolean, withRoles?: boolean, withMilestones?: boolean, withStages?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getCaseInstance.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling getCaseInstance.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (withData !== undefined && withData !== null) {
            queryParameters = queryParameters.set('withData', <any>withData);
        }
        if (withRoles !== undefined && withRoles !== null) {
            queryParameters = queryParameters.set('withRoles', <any>withRoles);
        }
        if (withMilestones !== undefined && withMilestones !== null) {
            queryParameters = queryParameters.set('withMilestones', <any>withMilestones);
        }
        if (withStages !== undefined && withStages !== null) {
            queryParameters = queryParameters.set('withStages', <any>withStages);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CaseInstance>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns node instances for a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param completed optional flag that allows to control which node instances to load - active or completed, defaults to false loading only active ones
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCaseInstanceActiveNodes(containerId: string, caseId: string, completed?: boolean, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<NodeInstanceList>;
    public getCaseInstanceActiveNodes(containerId: string, caseId: string, completed?: boolean, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<NodeInstanceList>>;
    public getCaseInstanceActiveNodes(containerId: string, caseId: string, completed?: boolean, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<NodeInstanceList>>;
    public getCaseInstanceActiveNodes(containerId: string, caseId: string, completed?: boolean, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getCaseInstanceActiveNodes.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling getCaseInstanceActiveNodes.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (completed !== undefined && completed !== null) {
            queryParameters = queryParameters.set('completed', <any>completed);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<NodeInstanceList>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/nodes/instances`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns ad hoc fragments for a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCaseInstanceAdHocFragments(containerId: string, caseId: string, observe?: 'body', reportProgress?: boolean): Observable<CaseAdHocFragmentList>;
    public getCaseInstanceAdHocFragments(containerId: string, caseId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CaseAdHocFragmentList>>;
    public getCaseInstanceAdHocFragments(containerId: string, caseId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CaseAdHocFragmentList>>;
    public getCaseInstanceAdHocFragments(containerId: string, caseId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getCaseInstanceAdHocFragments.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling getCaseInstanceAdHocFragments.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CaseAdHocFragmentList>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/adhocfragments`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns comments from a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param sort optional sort column, no default
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCaseInstanceComments(containerId: string, caseId: string, sort?: string, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<CaseCommentList>;
    public getCaseInstanceComments(containerId: string, caseId: string, sort?: string, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CaseCommentList>>;
    public getCaseInstanceComments(containerId: string, caseId: string, sort?: string, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CaseCommentList>>;
    public getCaseInstanceComments(containerId: string, caseId: string, sort?: string, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getCaseInstanceComments.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling getCaseInstanceComments.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CaseCommentList>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/comments`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns data from the case files of a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param name optional name(s) of the data items to retrieve
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCaseInstanceData(containerId: string, caseId: string, name?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<{ [key: string]: any; }>;
    public getCaseInstanceData(containerId: string, caseId: string, name?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{ [key: string]: any; }>>;
    public getCaseInstanceData(containerId: string, caseId: string, name?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<{ [key: string]: any; }>>;
    public getCaseInstanceData(containerId: string, caseId: string, name?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getCaseInstanceData.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling getCaseInstanceData.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (name) {
            name.forEach((element) => {
                queryParameters = queryParameters.append('name', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<{ [key: string]: any; }>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/caseFile`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns the value of a specified case file data item in a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param dataId name of the data item within case file to retrieve
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCaseInstanceDataByName(containerId: string, caseId: string, dataId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getCaseInstanceDataByName(containerId: string, caseId: string, dataId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getCaseInstanceDataByName(containerId: string, caseId: string, dataId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getCaseInstanceDataByName(containerId: string, caseId: string, dataId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getCaseInstanceDataByName.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling getCaseInstanceDataByName.');
        }

        if (dataId === null || dataId === undefined) {
            throw new Error('Required parameter dataId was null or undefined when calling getCaseInstanceDataByName.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/caseFile/${encodeURIComponent(String(dataId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns milestones for a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param achievedOnly optional flag that allows to control which milestones to load - achieved only or actives ones too, defaults to true
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCaseInstanceMilestones(containerId: string, caseId: string, achievedOnly?: boolean, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<CaseMilestoneList>;
    public getCaseInstanceMilestones(containerId: string, caseId: string, achievedOnly?: boolean, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CaseMilestoneList>>;
    public getCaseInstanceMilestones(containerId: string, caseId: string, achievedOnly?: boolean, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CaseMilestoneList>>;
    public getCaseInstanceMilestones(containerId: string, caseId: string, achievedOnly?: boolean, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getCaseInstanceMilestones.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling getCaseInstanceMilestones.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (achievedOnly !== undefined && achievedOnly !== null) {
            queryParameters = queryParameters.set('achievedOnly', <any>achievedOnly);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CaseMilestoneList>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/milestones`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns process instances in a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param status optional process instance status (active, completed, aborted) - defaults ot active (1) only
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCaseInstanceProcessInstance(containerId: string, caseId: string, status?: Array<1 | 2 | 3>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ProcessInstanceList>;
    public getCaseInstanceProcessInstance(containerId: string, caseId: string, status?: Array<1 | 2 | 3>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessInstanceList>>;
    public getCaseInstanceProcessInstance(containerId: string, caseId: string, status?: Array<1 | 2 | 3>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessInstanceList>>;
    public getCaseInstanceProcessInstance(containerId: string, caseId: string, status?: Array<1 | 2 | 3>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getCaseInstanceProcessInstance.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling getCaseInstanceProcessInstance.');
        }






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('status', <any>element);
            })
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ProcessInstanceList>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/processes/instances`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns role assignments for a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCaseInstanceRoleAssignments(containerId: string, caseId: string, observe?: 'body', reportProgress?: boolean): Observable<CaseRoleAssignmentList>;
    public getCaseInstanceRoleAssignments(containerId: string, caseId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CaseRoleAssignmentList>>;
    public getCaseInstanceRoleAssignments(containerId: string, caseId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CaseRoleAssignmentList>>;
    public getCaseInstanceRoleAssignments(containerId: string, caseId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getCaseInstanceRoleAssignments.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling getCaseInstanceRoleAssignments.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CaseRoleAssignmentList>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/roles`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns stages for a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param activeOnly optional flag that allows to control which stages to load - active only or completed ones too, defaults to true
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCaseInstanceStages(containerId: string, caseId: string, activeOnly?: boolean, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<CaseStageList>;
    public getCaseInstanceStages(containerId: string, caseId: string, activeOnly?: boolean, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CaseStageList>>;
    public getCaseInstanceStages(containerId: string, caseId: string, activeOnly?: boolean, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CaseStageList>>;
    public getCaseInstanceStages(containerId: string, caseId: string, activeOnly?: boolean, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getCaseInstanceStages.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling getCaseInstanceStages.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('activeOnly', <any>activeOnly);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CaseStageList>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/stages`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns case instances in a specified KIE container.
     *
     * @param containerId container id that should be used to filter case instances
     * @param status optional case instance status (open, closed, canceled) - defaults ot open (1) only
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param withData optional flag to load data when loading case instance
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCaseInstancesByContainer(containerId: string, status?: Array<'open' | 'closed' | 'cancelled'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, withData?: boolean, observe?: 'body', reportProgress?: boolean): Observable<CaseInstanceList>;
    public getCaseInstancesByContainer(containerId: string, status?: Array<'open' | 'closed' | 'cancelled'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, withData?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CaseInstanceList>>;
    public getCaseInstancesByContainer(containerId: string, status?: Array<'open' | 'closed' | 'cancelled'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, withData?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CaseInstanceList>>;
    public getCaseInstancesByContainer(containerId: string, status?: Array<'open' | 'closed' | 'cancelled'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, withData?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getCaseInstancesByContainer.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('status', <any>element);
            })
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }
        if (withData !== undefined && withData !== null) {
            queryParameters = queryParameters.set('withData', <any>withData);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CaseInstanceList>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns case instances for a specified case definition.
     *
     * @param containerId container id that should be used to filter case instances
     * @param caseDefId case definition id that should be used to filter case instances
     * @param status optional case instance status (open, closed, canceled) - defaults ot open (1) only
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param withData optional flag to load data when loading case instance
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCaseInstancesByDefinition(containerId: string, caseDefId: string, status?: Array<'open' | 'closed' | 'cancelled'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, withData?: boolean, observe?: 'body', reportProgress?: boolean): Observable<CaseInstanceList>;
    public getCaseInstancesByDefinition(containerId: string, caseDefId: string, status?: Array<'open' | 'closed' | 'cancelled'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, withData?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CaseInstanceList>>;
    public getCaseInstancesByDefinition(containerId: string, caseDefId: string, status?: Array<'open' | 'closed' | 'cancelled'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, withData?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CaseInstanceList>>;
    public getCaseInstancesByDefinition(containerId: string, caseDefId: string, status?: Array<'open' | 'closed' | 'cancelled'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, withData?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getCaseInstancesByDefinition.');
        }

        if (caseDefId === null || caseDefId === undefined) {
            throw new Error('Required parameter caseDefId was null or undefined when calling getCaseInstancesByDefinition.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('status', <any>element);
            })
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }
        if (withData !== undefined && withData !== null) {
            queryParameters = queryParameters.set('withData', <any>withData);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CaseInstanceList>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/${encodeURIComponent(String(caseDefId))}/instances`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Adds data as case files in a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param body map of data to be placed in case file as Map
     * @param restrictedTo optional role name(s) that given data should be restricted to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putCaseInstanceData(containerId: string, caseId: string, body: string, restrictedTo?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public putCaseInstanceData(containerId: string, caseId: string, body: string, restrictedTo?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public putCaseInstanceData(containerId: string, caseId: string, body: string, restrictedTo?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public putCaseInstanceData(containerId: string, caseId: string, body: string, restrictedTo?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling putCaseInstanceData.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling putCaseInstanceData.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putCaseInstanceData.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (restrictedTo) {
            restrictedTo.forEach((element) => {
                queryParameters = queryParameters.append('restrictedTo', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/caseFile`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Adds a single data item as a case file in a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param dataId name of the data item to be added to case file
     * @param body data to be placed in case file, any type can be provided
     * @param restrictedTo optional role name(s) that given data should be restricted to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putCaseInstanceDataByName(containerId: string, caseId: string, dataId: string, body: string, restrictedTo?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public putCaseInstanceDataByName(containerId: string, caseId: string, dataId: string, body: string, restrictedTo?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public putCaseInstanceDataByName(containerId: string, caseId: string, dataId: string, body: string, restrictedTo?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public putCaseInstanceDataByName(containerId: string, caseId: string, dataId: string, body: string, restrictedTo?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling putCaseInstanceDataByName.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling putCaseInstanceDataByName.');
        }

        if (dataId === null || dataId === undefined) {
            throw new Error('Required parameter dataId was null or undefined when calling putCaseInstanceDataByName.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putCaseInstanceDataByName.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (restrictedTo) {
            restrictedTo.forEach((element) => {
                queryParameters = queryParameters.append('restrictedTo', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/caseFile/${encodeURIComponent(String(dataId))}`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specified comment in a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param caseCommentId identifier of the comment to be removed
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeComment(containerId: string, caseId: string, caseCommentId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removeComment(containerId: string, caseId: string, caseCommentId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removeComment(containerId: string, caseId: string, caseCommentId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removeComment(containerId: string, caseId: string, caseCommentId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling removeComment.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling removeComment.');
        }

        if (caseCommentId === null || caseCommentId === undefined) {
            throw new Error('Required parameter caseCommentId was null or undefined when calling removeComment.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/comments/${encodeURIComponent(String(caseCommentId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Removes an assigned case role from a specified user and group for a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param caseRoleName name of the case role the assignment should be removed
     * @param user user to be removed from case role for given case instance
     * @param group group to be removed from case role for given case instance
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeRoleAssignment(containerId: string, caseId: string, caseRoleName: string, user: string, group: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removeRoleAssignment(containerId: string, caseId: string, caseRoleName: string, user: string, group: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removeRoleAssignment(containerId: string, caseId: string, caseRoleName: string, user: string, group: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removeRoleAssignment(containerId: string, caseId: string, caseRoleName: string, user: string, group: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling removeRoleAssignment.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling removeRoleAssignment.');
        }

        if (caseRoleName === null || caseRoleName === undefined) {
            throw new Error('Required parameter caseRoleName was null or undefined when calling removeRoleAssignment.');
        }

        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling removeRoleAssignment.');
        }

        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling removeRoleAssignment.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }
        if (group !== undefined && group !== null) {
            queryParameters = queryParameters.set('group', <any>group);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/roles/${encodeURIComponent(String(caseRoleName))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Reopens a closed case instance for a specified case definition.
     *
     * @param containerId container id where the case definition resides
     * @param caseDefId case definition id that new instance should be created from
     * @param caseId identifier of the case instance
     * @param body optional CaseFile with variables and/or case role assignments
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public reopenCase(containerId: string, caseDefId: string, caseId: string, body?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public reopenCase(containerId: string, caseDefId: string, caseId: string, body?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public reopenCase(containerId: string, caseDefId: string, caseId: string, body?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public reopenCase(containerId: string, caseDefId: string, caseId: string, body?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling reopenCase.');
        }

        if (caseDefId === null || caseDefId === undefined) {
            throw new Error('Required parameter caseDefId was null or undefined when calling reopenCase.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling reopenCase.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/${encodeURIComponent(String(caseDefId))}/instances/${encodeURIComponent(String(caseId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Starts a new case instance for a specified case definition.
     *
     * @param containerId container id where the case definition resides
     * @param caseDefId case definition id that new instance should be created from
     * @param body optional CaseFile with variables and/or case role assignments
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public startCase(containerId: string, caseDefId: string, body?: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public startCase(containerId: string, caseDefId: string, body?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public startCase(containerId: string, caseDefId: string, body?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public startCase(containerId: string, caseDefId: string, body?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling startCase.');
        }

        if (caseDefId === null || caseDefId === undefined) {
            throw new Error('Required parameter caseDefId was null or undefined when calling startCase.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/${encodeURIComponent(String(caseDefId))}/instances`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Triggers a specified ad hoc fragment in a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param nodeName name of the adhoc fragment to be triggered
     * @param body optional data to be given when triggering adhoc fragment
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public triggerAdHocNode(containerId: string, caseId: string, nodeName: string, body?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public triggerAdHocNode(containerId: string, caseId: string, nodeName: string, body?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public triggerAdHocNode(containerId: string, caseId: string, nodeName: string, body?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public triggerAdHocNode(containerId: string, caseId: string, nodeName: string, body?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling triggerAdHocNode.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling triggerAdHocNode.');
        }

        if (nodeName === null || nodeName === undefined) {
            throw new Error('Required parameter nodeName was null or undefined when calling triggerAdHocNode.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/tasks/${encodeURIComponent(String(nodeName))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Triggers a specified ad hoc fragment in the specified stage of a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param caseStageId identifier of the stage within case instance where adhoc fragment should be triggered
     * @param nodeName name of the adhoc fragment to be triggered
     * @param body optional data to be given when triggering adhoc fragment
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public triggerAdHocNodeInStage(containerId: string, caseId: string, caseStageId: string, nodeName: string, body?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public triggerAdHocNodeInStage(containerId: string, caseId: string, caseStageId: string, nodeName: string, body?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public triggerAdHocNodeInStage(containerId: string, caseId: string, caseStageId: string, nodeName: string, body?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public triggerAdHocNodeInStage(containerId: string, caseId: string, caseStageId: string, nodeName: string, body?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling triggerAdHocNodeInStage.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling triggerAdHocNodeInStage.');
        }

        if (caseStageId === null || caseStageId === undefined) {
            throw new Error('Required parameter caseStageId was null or undefined when calling triggerAdHocNodeInStage.');
        }

        if (nodeName === null || nodeName === undefined) {
            throw new Error('Required parameter nodeName was null or undefined when calling triggerAdHocNodeInStage.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/stages/${encodeURIComponent(String(caseStageId))}/tasks/${encodeURIComponent(String(nodeName))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specified comment in a specified case instance.
     *
     * @param containerId container id that case instance belongs to
     * @param caseId identifier of the case instance
     * @param caseCommentId identifier of the comment to be updated
     * @param body actual content of the comment to be updated to as String
     * @param author optional user id to be used instead of authenticated user - only when bypass authenticated user is enabled
     * @param restrictedTo optional role name(s) that given comment should be restricted to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateComment(containerId: string, caseId: string, caseCommentId: string, body: string, author?: string, restrictedTo?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateComment(containerId: string, caseId: string, caseCommentId: string, body: string, author?: string, restrictedTo?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateComment(containerId: string, caseId: string, caseCommentId: string, body: string, author?: string, restrictedTo?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateComment(containerId: string, caseId: string, caseCommentId: string, body: string, author?: string, restrictedTo?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling updateComment.');
        }

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling updateComment.');
        }

        if (caseCommentId === null || caseCommentId === undefined) {
            throw new Error('Required parameter caseCommentId was null or undefined when calling updateComment.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateComment.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (author !== undefined && author !== null) {
            queryParameters = queryParameters.set('author', <any>author);
        }
        if (restrictedTo) {
            restrictedTo.forEach((element) => {
                queryParameters = queryParameters.append('restrictedTo', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/cases/instances/${encodeURIComponent(String(caseId))}/comments/${encodeURIComponent(String(caseCommentId))}`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
