/**
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable } from 'rxjs';

import { CaseDefinitionList } from '../model/caseDefinitionList';
import { CaseFileDataItemList } from '../model/caseFileDataItemList';
import { CaseInstanceCustomVarsList } from '../model/caseInstanceCustomVarsList';
import { CaseInstanceList } from '../model/caseInstanceList';
import { CaseUserTaskWithVariablesList } from '../model/caseUserTaskWithVariablesList';
import { ProcessDefinitionList } from '../model/processDefinitionList';
import { TaskSummaryList } from '../model/taskSummaryList';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class CaseQueriesService {

    protected basePath = 'https://localhost/bpm/rest';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Returns a specified case definition from all KIE containers.
     *
     * @param filter case definition id or name that case definitions will be filtered by
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCaseDefinitions(filter: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<CaseDefinitionList>;
    public getCaseDefinitions(filter: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CaseDefinitionList>>;
    public getCaseDefinitions(filter: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CaseDefinitionList>>;
    public getCaseDefinitions(filter: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling getCaseDefinitions.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (filter !== undefined && filter !== null) {
            queryParameters = queryParameters.set('filter', <any>filter);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CaseDefinitionList>(`${this.basePath}/server/queries/cases`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns case file data items for a specified case instance.
     *
     * @param caseId case instance identifier that data items should belong to
     * @param name optionally filter by data item names
     * @param type optionally filter by data item types
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCaseInstanceDataItems(caseId: string, name?: Array<string>, type?: Array<string>, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<CaseFileDataItemList>;
    public getCaseInstanceDataItems(caseId: string, name?: Array<string>, type?: Array<string>, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CaseFileDataItemList>>;
    public getCaseInstanceDataItems(caseId: string, name?: Array<string>, type?: Array<string>, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CaseFileDataItemList>>;
    public getCaseInstanceDataItems(caseId: string, name?: Array<string>, type?: Array<string>, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling getCaseInstanceDataItems.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (name) {
            name.forEach((element) => {
                queryParameters = queryParameters.append('name', <any>element);
            })
        }
        if (type) {
            type.forEach((element) => {
                queryParameters = queryParameters.append('type', <any>element);
            })
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CaseFileDataItemList>(`${this.basePath}/server/queries/cases/instances/${encodeURIComponent(String(caseId))}/caseFile`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns tasks for business administrators in a specified case instance.
     *
     * @param caseId case instance identifier that tasks should belong to
     * @param user optional user id to be used instead of authenticated user - only when bypass authenticated user is enabled
     * @param status optional task status (Created, Ready, Reserved, InProgress, Suspended, Completed, Failed, Error, Exited, Obsolete)
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCaseInstanceTasksAsAdmin(caseId: string, user?: string, status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TaskSummaryList>;
    public getCaseInstanceTasksAsAdmin(caseId: string, user?: string, status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TaskSummaryList>>;
    public getCaseInstanceTasksAsAdmin(caseId: string, user?: string, status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TaskSummaryList>>;
    public getCaseInstanceTasksAsAdmin(caseId: string, user?: string, status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling getCaseInstanceTasksAsAdmin.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('status', <any>element);
            })
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TaskSummaryList>(`${this.basePath}/server/queries/cases/instances/${encodeURIComponent(String(caseId))}/tasks/instances/admins`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns tasks for potential owners in a specified case instance.
     *
     * @param caseId case instance identifier that tasks should belong to
     * @param user optional user id to be used instead of authenticated user - only when bypass authenticated user is enabled
     * @param status optional task status (Created, Ready, Reserved, InProgress, Suspended, Completed, Failed, Error, Exited, Obsolete)
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCaseInstanceTasksAsPotentialOwner(caseId: string, user?: string, status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TaskSummaryList>;
    public getCaseInstanceTasksAsPotentialOwner(caseId: string, user?: string, status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TaskSummaryList>>;
    public getCaseInstanceTasksAsPotentialOwner(caseId: string, user?: string, status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TaskSummaryList>>;
    public getCaseInstanceTasksAsPotentialOwner(caseId: string, user?: string, status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling getCaseInstanceTasksAsPotentialOwner.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('status', <any>element);
            })
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TaskSummaryList>(`${this.basePath}/server/queries/cases/instances/${encodeURIComponent(String(caseId))}/tasks/instances/pot-owners`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns tasks for stakeholders in a specified case instance.
     *
     * @param caseId case instance identifier that tasks should belong to
     * @param user optional user id to be used instead of authenticated user - only when bypass authenticated user is enabled
     * @param status optional task status (Created, Ready, Reserved, InProgress, Suspended, Completed, Failed, Error, Exited, Obsolete)
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCaseInstanceTasksAsStakeholder(caseId: string, user?: string, status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TaskSummaryList>;
    public getCaseInstanceTasksAsStakeholder(caseId: string, user?: string, status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TaskSummaryList>>;
    public getCaseInstanceTasksAsStakeholder(caseId: string, user?: string, status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TaskSummaryList>>;
    public getCaseInstanceTasksAsStakeholder(caseId: string, user?: string, status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (caseId === null || caseId === undefined) {
            throw new Error('Required parameter caseId was null or undefined when calling getCaseInstanceTasksAsStakeholder.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('status', <any>element);
            })
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TaskSummaryList>(`${this.basePath}/server/queries/cases/instances/${encodeURIComponent(String(caseId))}/tasks/instances/stakeholders`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns cases instances with authentication checks.
     *
     * @param dataItemName data item name that case instances will be filtered by
     * @param dataItemValue data item value that case instances will be filtered by
     * @param owner case instance owner that case instances will be filtered by
     * @param status optional case instance status (open, closed, canceled) - defaults ot open (1) only
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param withData optional flag to load data when loading case instance
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCaseInstances1(dataItemName?: string, dataItemValue?: string, owner?: string, status?: Array<'open' | 'closed' | 'cancelled'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, withData?: boolean, observe?: 'body', reportProgress?: boolean): Observable<CaseInstanceList>;
    public getCaseInstances1(dataItemName?: string, dataItemValue?: string, owner?: string, status?: Array<'open' | 'closed' | 'cancelled'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, withData?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CaseInstanceList>>;
    public getCaseInstances1(dataItemName?: string, dataItemValue?: string, owner?: string, status?: Array<'open' | 'closed' | 'cancelled'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, withData?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CaseInstanceList>>;
    public getCaseInstances1(dataItemName?: string, dataItemValue?: string, owner?: string, status?: Array<'open' | 'closed' | 'cancelled'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, withData?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {










        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (dataItemName !== undefined && dataItemName !== null) {
            queryParameters = queryParameters.set('dataItemName', <any>dataItemName);
        }
        if (dataItemValue !== undefined && dataItemValue !== null) {
            queryParameters = queryParameters.set('dataItemValue', <any>dataItemValue);
        }
        if (owner !== undefined && owner !== null) {
            queryParameters = queryParameters.set('owner', <any>owner);
        }
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('status', <any>element);
            })
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }
        if (withData !== undefined && withData !== null) {
            queryParameters = queryParameters.set('withData', <any>withData);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CaseInstanceList>(`${this.basePath}/server/queries/cases/instances`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns cases instances that involve the querying user in a specified role.
     *
     * @param caseRoleName case role that instances should be found for
     * @param status optional case instance status (open, closed, canceled) - defaults ot open (1) only
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param withData optional flag to load data when loading case instance
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCaseInstancesByRole(caseRoleName: string, status?: Array<'open' | 'closed' | 'cancelled'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, withData?: boolean, observe?: 'body', reportProgress?: boolean): Observable<CaseInstanceList>;
    public getCaseInstancesByRole(caseRoleName: string, status?: Array<'open' | 'closed' | 'cancelled'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, withData?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CaseInstanceList>>;
    public getCaseInstancesByRole(caseRoleName: string, status?: Array<'open' | 'closed' | 'cancelled'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, withData?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CaseInstanceList>>;
    public getCaseInstancesByRole(caseRoleName: string, status?: Array<'open' | 'closed' | 'cancelled'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, withData?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (caseRoleName === null || caseRoleName === undefined) {
            throw new Error('Required parameter caseRoleName was null or undefined when calling getCaseInstancesByRole.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('status', <any>element);
            })
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }
        if (withData !== undefined && withData !== null) {
            queryParameters = queryParameters.set('withData', <any>withData);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CaseInstanceList>(`${this.basePath}/server/queries/cases/${encodeURIComponent(String(caseRoleName))}/instances`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a specified process associated with case definitions from all KIE containers.
     *
     * @param filter process definition id or name that process definitions will be filtered by
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessDefinitions(filter: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ProcessDefinitionList>;
    public getProcessDefinitions(filter: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessDefinitionList>>;
    public getProcessDefinitions(filter: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessDefinitionList>>;
    public getProcessDefinitions(filter: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling getProcessDefinitions.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (filter !== undefined && filter !== null) {
            queryParameters = queryParameters.set('filter', <any>filter);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ProcessDefinitionList>(`${this.basePath}/server/queries/cases/processes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns processes associated with case definitions in a specified KIE container.
     *
     * @param containerId container id that process definitions should be filtered by
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessDefinitionsByContainer(containerId: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ProcessDefinitionList>;
    public getProcessDefinitionsByContainer(containerId: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessDefinitionList>>;
    public getProcessDefinitionsByContainer(containerId: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessDefinitionList>>;
    public getProcessDefinitionsByContainer(containerId: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getProcessDefinitionsByContainer.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ProcessDefinitionList>(`${this.basePath}/server/queries/cases/${encodeURIComponent(String(containerId))}/processes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Queries cases by variables and tasks
     *
     * @param body
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public queryCaseByVariables(body?: string, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<CaseInstanceCustomVarsList>;
    public queryCaseByVariables(body?: string, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CaseInstanceCustomVarsList>>;
    public queryCaseByVariables(body?: string, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CaseInstanceCustomVarsList>>;
    public queryCaseByVariables(body?: string, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<CaseInstanceCustomVarsList>(`${this.basePath}/server/queries/cases/variables/cases`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Queries cases tasks by variables
     *
     * @param body
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public queryCaseUserTasksByVariables(body?: string, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<CaseUserTaskWithVariablesList>;
    public queryCaseUserTasksByVariables(body?: string, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CaseUserTaskWithVariablesList>>;
    public queryCaseUserTasksByVariables(body?: string, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CaseUserTaskWithVariablesList>>;
    public queryCaseUserTasksByVariables(body?: string, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<CaseUserTaskWithVariablesList>(`${this.basePath}/server/queries/cases/variables/cases/tasks`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
