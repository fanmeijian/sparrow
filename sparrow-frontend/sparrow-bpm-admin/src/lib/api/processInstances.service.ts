/**
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { NodeInstanceList } from '../model/nodeInstanceList';
import { ProcessDefinitionList } from '../model/processDefinitionList';
import { ProcessInstance } from '../model/processInstance';
import { ProcessInstanceList } from '../model/processInstanceList';
import { VariableInstanceList } from '../model/variableInstanceList';
import { WorkItemInstance } from '../model/workItemInstance';
import { WorkItemInstanceList } from '../model/workItemInstanceList';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ProcessInstancesService {

    protected basePath = 'https://localhost/bpm/rest';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Aborts a specified process instance in a specified KIE container.
     *
     * @param containerId container id that process instance belongs to
     * @param processInstanceId identifier of the process instance to be aborted
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public abortProcessInstance(containerId: string, processInstanceId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public abortProcessInstance(containerId: string, processInstanceId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public abortProcessInstance(containerId: string, processInstanceId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public abortProcessInstance(containerId: string, processInstanceId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling abortProcessInstance.');
        }

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling abortProcessInstance.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/instances/${encodeURIComponent(String(processInstanceId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Aborts multiple specified process instances in a specified KIE container.
     *
     * @param containerId container id that process instance belongs to
     * @param instanceId list of identifiers of the process instances to be aborted
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public abortProcessInstances(containerId: string, instanceId: Array<number>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public abortProcessInstances(containerId: string, instanceId: Array<number>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public abortProcessInstances(containerId: string, instanceId: Array<number>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public abortProcessInstances(containerId: string, instanceId: Array<number>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling abortProcessInstances.');
        }

        if (instanceId === null || instanceId === undefined) {
            throw new Error('Required parameter instanceId was null or undefined when calling abortProcessInstances.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (instanceId) {
            instanceId.forEach((element) => {
                queryParameters = queryParameters.append('instanceId', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/instances`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Aborts a specified work item for a specified process instance.
     *
     * @param containerId container id that process instance belongs to
     * @param processInstanceId identifier of the process instance that work item belongs to
     * @param workItemId identifier of the work item to abort
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public abortWorkItem(containerId: string, processInstanceId: number, workItemId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public abortWorkItem(containerId: string, processInstanceId: number, workItemId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public abortWorkItem(containerId: string, processInstanceId: number, workItemId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public abortWorkItem(containerId: string, processInstanceId: number, workItemId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling abortWorkItem.');
        }

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling abortWorkItem.');
        }

        if (workItemId === null || workItemId === undefined) {
            throw new Error('Required parameter workItemId was null or undefined when calling abortWorkItem.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.put<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/instances/${encodeURIComponent(String(processInstanceId))}/workitems/${encodeURIComponent(String(workItemId))}/aborted`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Completes a specified work item for a specified process instance.
     *
     * @param containerId container id that process instance belongs to
     * @param processInstanceId identifier of the process instance that work item belongs to
     * @param workItemId identifier of the work item to complete
     * @param body optional outcome data give as map
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public completeWorkItem(containerId: string, processInstanceId: number, workItemId: number, body?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public completeWorkItem(containerId: string, processInstanceId: number, workItemId: number, body?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public completeWorkItem(containerId: string, processInstanceId: number, workItemId: number, body?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public completeWorkItem(containerId: string, processInstanceId: number, workItemId: number, body?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling completeWorkItem.');
        }

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling completeWorkItem.');
        }

        if (workItemId === null || workItemId === undefined) {
            throw new Error('Required parameter workItemId was null or undefined when calling completeWorkItem.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/instances/${encodeURIComponent(String(processInstanceId))}/workitems/${encodeURIComponent(String(workItemId))}/completed`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all available signal names for a specified process instance.
     *
     * @param containerId container id that process instance belongs to
     * @param processInstanceId identifier of the process instance that signals should be collected for
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAvailableSignals(containerId: string, processInstanceId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public getAvailableSignals(containerId: string, processInstanceId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public getAvailableSignals(containerId: string, processInstanceId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public getAvailableSignals(containerId: string, processInstanceId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getAvailableSignals.');
        }

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling getAvailableSignals.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<string>>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/instances/${encodeURIComponent(String(processInstanceId))}/signals`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns information about a specified process instance in a specified KIE container.
     *
     * @param containerId container id that process instance belongs to
     * @param processInstanceId identifier of the process instance to be fetched
     * @param withVars indicates if process instance variables should be loaded or not
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessInstance(containerId: string, processInstanceId: number, withVars?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ProcessInstance>;
    public getProcessInstance(containerId: string, processInstanceId: number, withVars?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessInstance>>;
    public getProcessInstance(containerId: string, processInstanceId: number, withVars?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessInstance>>;
    public getProcessInstance(containerId: string, processInstanceId: number, withVars?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getProcessInstance.');
        }

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling getProcessInstance.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (withVars !== undefined && withVars !== null) {
            queryParameters = queryParameters.set('withVars', <any>withVars);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ProcessInstance>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/instances/${encodeURIComponent(String(processInstanceId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns node instances for the specified process instance.
     *
     * @param containerId container id that process instance belongs to
     * @param processInstanceId identifier of the process instance that history should be collected for
     * @param activeOnly instructs if active nodes only should be collected, defaults to false
     * @param completedOnly instructs if completed nodes only should be collected, defaults to false
     * @param processInstanceHistoryType entry type from the history
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessInstanceHistory(containerId: string, processInstanceId: number, activeOnly?: boolean, completedOnly?: boolean, processInstanceHistoryType?: string, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<NodeInstanceList>;
    public getProcessInstanceHistory(containerId: string, processInstanceId: number, activeOnly?: boolean, completedOnly?: boolean, processInstanceHistoryType?: string, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<NodeInstanceList>>;
    public getProcessInstanceHistory(containerId: string, processInstanceId: number, activeOnly?: boolean, completedOnly?: boolean, processInstanceHistoryType?: string, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<NodeInstanceList>>;
    public getProcessInstanceHistory(containerId: string, processInstanceId: number, activeOnly?: boolean, completedOnly?: boolean, processInstanceHistoryType?: string, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getProcessInstanceHistory.');
        }

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling getProcessInstanceHistory.');
        }






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('activeOnly', <any>activeOnly);
        }
        if (completedOnly !== undefined && completedOnly !== null) {
            queryParameters = queryParameters.set('completedOnly', <any>completedOnly);
        }
        if (processInstanceHistoryType !== undefined && processInstanceHistoryType !== null) {
            queryParameters = queryParameters.set('processInstanceHistoryType', <any>processInstanceHistoryType);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<NodeInstanceList>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/instances/${encodeURIComponent(String(processInstanceId))}/nodes/instances`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns the value of a specified variable in a specified process instance.
     *
     * @param containerId container id that process instance belongs to
     * @param processInstanceId identifier of the process instance that variable should be retrieved from
     * @param varName variable name to be retrieved
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessInstanceVariable(containerId: string, processInstanceId: number, varName: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getProcessInstanceVariable(containerId: string, processInstanceId: number, varName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getProcessInstanceVariable(containerId: string, processInstanceId: number, varName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getProcessInstanceVariable(containerId: string, processInstanceId: number, varName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getProcessInstanceVariable.');
        }

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling getProcessInstanceVariable.');
        }

        if (varName === null || varName === undefined) {
            throw new Error('Required parameter varName was null or undefined when calling getProcessInstanceVariable.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/instances/${encodeURIComponent(String(processInstanceId))}/variable/${encodeURIComponent(String(varName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves all variables for a specified process instance as a map in which the key is the variable name and the value is the variable value.
     *
     * @param containerId container id that process instance belongs to
     * @param processInstanceId identifier of the process instance that variables should be retrieved from
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessInstanceVariables(containerId: string, processInstanceId: number, observe?: 'body', reportProgress?: boolean): Observable<{ [key: string]: any; }>;
    public getProcessInstanceVariables(containerId: string, processInstanceId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{ [key: string]: any; }>>;
    public getProcessInstanceVariables(containerId: string, processInstanceId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<{ [key: string]: any; }>>;
    public getProcessInstanceVariables(containerId: string, processInstanceId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getProcessInstanceVariables.');
        }

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling getProcessInstanceVariables.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<{ [key: string]: any; }>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/instances/${encodeURIComponent(String(processInstanceId))}/variables`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of process instances for which a specified process instance is a parent process instance
     *
     * @param containerId container id that process instance belongs to
     * @param processInstanceId identifier of the parent process instance that process instances should be collected for
     * @param status optional process instance status (active, completed, aborted) - defaults ot active (1) only
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessInstances(containerId: string, processInstanceId: number, status?: Array<1 | 2 | 3>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ProcessInstanceList>;
    public getProcessInstances(containerId: string, processInstanceId: number, status?: Array<1 | 2 | 3>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessInstanceList>>;
    public getProcessInstances(containerId: string, processInstanceId: number, status?: Array<1 | 2 | 3>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessInstanceList>>;
    public getProcessInstances(containerId: string, processInstanceId: number, status?: Array<1 | 2 | 3>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getProcessInstances.');
        }

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling getProcessInstances.');
        }






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('status', <any>element);
            })
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ProcessInstanceList>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/instances/${encodeURIComponent(String(processInstanceId))}/processes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of process instances in a specified KIE container.
     *
     * @param containerId container id that process instance belongs to
     * @param status optional process instance status (active, completed, aborted) - defaults ot active (1) only
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessInstancesByDeploymentId(containerId: string, status?: Array<1 | 2 | 3>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ProcessInstanceList>;
    public getProcessInstancesByDeploymentId(containerId: string, status?: Array<1 | 2 | 3>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessInstanceList>>;
    public getProcessInstancesByDeploymentId(containerId: string, status?: Array<1 | 2 | 3>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessInstanceList>>;
    public getProcessInstancesByDeploymentId(containerId: string, status?: Array<1 | 2 | 3>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getProcessInstancesByDeploymentId.');
        }






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('status', <any>element);
            })
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ProcessInstanceList>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/instances`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of process definitions in a specified KIE container.
     *
     * @param containerId container id that process instance belongs to
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessesByDeploymentId(containerId: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ProcessDefinitionList>;
    public getProcessesByDeploymentId(containerId: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessDefinitionList>>;
    public getProcessesByDeploymentId(containerId: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessDefinitionList>>;
    public getProcessesByDeploymentId(containerId: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getProcessesByDeploymentId.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ProcessDefinitionList>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns the history of a specified variable in a specified process instance.
     *
     * @param containerId container id that process instance belongs to
     * @param processInstanceId identifier of the process instance that variable history should be collected for
     * @param varName name of the variables that history should be collected for
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getVariableHistory(containerId: string, processInstanceId: number, varName: string, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<VariableInstanceList>;
    public getVariableHistory(containerId: string, processInstanceId: number, varName: string, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<VariableInstanceList>>;
    public getVariableHistory(containerId: string, processInstanceId: number, varName: string, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<VariableInstanceList>>;
    public getVariableHistory(containerId: string, processInstanceId: number, varName: string, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getVariableHistory.');
        }

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling getVariableHistory.');
        }

        if (varName === null || varName === undefined) {
            throw new Error('Required parameter varName was null or undefined when calling getVariableHistory.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<VariableInstanceList>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/instances/${encodeURIComponent(String(processInstanceId))}/variables/instances/${encodeURIComponent(String(varName))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns the current variable values of a specified process instance in a specified KIE container.
     *
     * @param containerId container id that process instance belongs to
     * @param processInstanceId identifier of the process instance that variables state should be collected for
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getVariablesCurrentState(containerId: string, processInstanceId: number, observe?: 'body', reportProgress?: boolean): Observable<VariableInstanceList>;
    public getVariablesCurrentState(containerId: string, processInstanceId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<VariableInstanceList>>;
    public getVariablesCurrentState(containerId: string, processInstanceId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<VariableInstanceList>>;
    public getVariablesCurrentState(containerId: string, processInstanceId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getVariablesCurrentState.');
        }

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling getVariablesCurrentState.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<VariableInstanceList>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/instances/${encodeURIComponent(String(processInstanceId))}/variables/instances`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns information about a specified work item for a specified process instance.
     *
     * @param containerId container id that process instance belongs to
     * @param processInstanceId identifier of the process instance that work item belongs to
     * @param workItemId identifier of the work item to retrieve
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getWorkItem(containerId: string, processInstanceId: number, workItemId: number, observe?: 'body', reportProgress?: boolean): Observable<WorkItemInstance>;
    public getWorkItem(containerId: string, processInstanceId: number, workItemId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WorkItemInstance>>;
    public getWorkItem(containerId: string, processInstanceId: number, workItemId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WorkItemInstance>>;
    public getWorkItem(containerId: string, processInstanceId: number, workItemId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getWorkItem.');
        }

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling getWorkItem.');
        }

        if (workItemId === null || workItemId === undefined) {
            throw new Error('Required parameter workItemId was null or undefined when calling getWorkItem.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<WorkItemInstance>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/instances/${encodeURIComponent(String(processInstanceId))}/workitems/${encodeURIComponent(String(workItemId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all work items for a specified process instance.
     *
     * @param containerId container id that process instance belongs to
     * @param processInstanceId identifier of the process instance that work items belong to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getWorkItemByProcessInstance(containerId: string, processInstanceId: number, observe?: 'body', reportProgress?: boolean): Observable<WorkItemInstanceList>;
    public getWorkItemByProcessInstance(containerId: string, processInstanceId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WorkItemInstanceList>>;
    public getWorkItemByProcessInstance(containerId: string, processInstanceId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WorkItemInstanceList>>;
    public getWorkItemByProcessInstance(containerId: string, processInstanceId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getWorkItemByProcessInstance.');
        }

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling getWorkItemByProcessInstance.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<WorkItemInstanceList>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/instances/${encodeURIComponent(String(processInstanceId))}/workitems`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates or updates a variable for a specified process instance.
     *
     * @param containerId container id that process instance belongs to
     * @param processInstanceId identifier of the process instance to be updated
     * @param varName name of the variable to be set/updated
     * @param body variable data - any type can be provided
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setProcessVariable(containerId: string, processInstanceId: number, varName: string, body: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setProcessVariable(containerId: string, processInstanceId: number, varName: string, body: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setProcessVariable(containerId: string, processInstanceId: number, varName: string, body: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setProcessVariable(containerId: string, processInstanceId: number, varName: string, body: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling setProcessVariable.');
        }

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling setProcessVariable.');
        }

        if (varName === null || varName === undefined) {
            throw new Error('Required parameter varName was null or undefined when calling setProcessVariable.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling setProcessVariable.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/instances/${encodeURIComponent(String(processInstanceId))}/variable/${encodeURIComponent(String(varName))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates the values of one or more variable for a specified process instance. The request is a map in which the key is the variable name and the value is the new variable value.
     *
     * @param containerId container id that process instance belongs to
     * @param processInstanceId identifier of the process instance to be updated
     * @param body variable data give as map
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setProcessVariables(containerId: string, processInstanceId: number, body: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setProcessVariables(containerId: string, processInstanceId: number, body: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setProcessVariables(containerId: string, processInstanceId: number, body: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setProcessVariables(containerId: string, processInstanceId: number, body: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling setProcessVariables.');
        }

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling setProcessVariables.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling setProcessVariables.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/instances/${encodeURIComponent(String(processInstanceId))}/variables`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Signals a specified process instance with a specified signal name and optional signal data.
     *
     * @param containerId container id that process instance belongs to
     * @param processInstanceId identifier of the process instance to be signaled
     * @param signalName signal name to be send to process instance
     * @param body optional event data - any type can be provided
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public signalProcessInstance(containerId: string, processInstanceId: number, signalName: string, body?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public signalProcessInstance(containerId: string, processInstanceId: number, signalName: string, body?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public signalProcessInstance(containerId: string, processInstanceId: number, signalName: string, body?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public signalProcessInstance(containerId: string, processInstanceId: number, signalName: string, body?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling signalProcessInstance.');
        }

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling signalProcessInstance.');
        }

        if (signalName === null || signalName === undefined) {
            throw new Error('Required parameter signalName was null or undefined when calling signalProcessInstance.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/instances/${encodeURIComponent(String(processInstanceId))}/signal/${encodeURIComponent(String(signalName))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Signals a specified process instance by correlation key with a specified signal name and optional signal data.
     *
     * @param containerId container id that process instance belongs to
     * @param correlationKey correlation key of the process instance to be signaled
     * @param signalName signal name to be sent to process instance
     * @param body optional event data - any type can be provided
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public signalProcessInstanceByCorrelationKey(containerId: string, correlationKey: string, signalName: string, body?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public signalProcessInstanceByCorrelationKey(containerId: string, correlationKey: string, signalName: string, body?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public signalProcessInstanceByCorrelationKey(containerId: string, correlationKey: string, signalName: string, body?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public signalProcessInstanceByCorrelationKey(containerId: string, correlationKey: string, signalName: string, body?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling signalProcessInstanceByCorrelationKey.');
        }

        if (correlationKey === null || correlationKey === undefined) {
            throw new Error('Required parameter correlationKey was null or undefined when calling signalProcessInstanceByCorrelationKey.');
        }

        if (signalName === null || signalName === undefined) {
            throw new Error('Required parameter signalName was null or undefined when calling signalProcessInstanceByCorrelationKey.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/instances/correlation/${encodeURIComponent(String(correlationKey))}/signal/${encodeURIComponent(String(signalName))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Signals multiple process instances with a specified signal name.
     *
     * @param containerId container id that process instance belongs to
     * @param signalName signal name to be send to process instance
     * @param instanceId list of identifiers of the process instances to be signaled
     * @param correlationKey list of correlationKeys of the process instances to be signaled
     * @param body optional event data - any type can be provided
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public signalProcessInstances(containerId: string, signalName: string, instanceId?: Array<number>, correlationKey?: Array<string>, body?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public signalProcessInstances(containerId: string, signalName: string, instanceId?: Array<number>, correlationKey?: Array<string>, body?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public signalProcessInstances(containerId: string, signalName: string, instanceId?: Array<number>, correlationKey?: Array<string>, body?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public signalProcessInstances(containerId: string, signalName: string, instanceId?: Array<number>, correlationKey?: Array<string>, body?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling signalProcessInstances.');
        }

        if (signalName === null || signalName === undefined) {
            throw new Error('Required parameter signalName was null or undefined when calling signalProcessInstances.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (instanceId) {
            instanceId.forEach((element) => {
                queryParameters = queryParameters.append('instanceId', <any>element);
            })
        }
        if (correlationKey) {
            correlationKey.forEach((element) => {
                queryParameters = queryParameters.append('correlationKey', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/instances/signal/${encodeURIComponent(String(signalName))}`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Starts a new process instance of a specified process.
     *
     * @param containerId container id where the process definition resides
     * @param processId process id that new instance should be created from
     * @param body optional map of process variables
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public startProcess(containerId: string, processId: string, body?: string, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public startProcess(containerId: string, processId: string, body?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public startProcess(containerId: string, processId: string, body?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public startProcess(containerId: string, processId: string, body?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling startProcess.');
        }

        if (processId === null || processId === undefined) {
            throw new Error('Required parameter processId was null or undefined when calling startProcess.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<number>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/${encodeURIComponent(String(processId))}/instances`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Starts a new process instance from the specific nodes
     *
     * @param containerId container id where the process definition resides
     * @param processId process instance id that new instance should be created from
     * @param body optional map of process variables
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public startProcessFromNodeIds(containerId: string, processId: string, body?: string, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public startProcessFromNodeIds(containerId: string, processId: string, body?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public startProcessFromNodeIds(containerId: string, processId: string, body?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public startProcessFromNodeIds(containerId: string, processId: string, body?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling startProcessFromNodeIds.');
        }

        if (processId === null || processId === undefined) {
            throw new Error('Required parameter processId was null or undefined when calling startProcessFromNodeIds.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<number>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/${encodeURIComponent(String(processId))}/instances/fromNodes`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Starts a new process instance of a specified process and assigns a new correlation key to the process instance.
     *
     * @param containerId container id where the process definition resides
     * @param processId process id that new instance should be created from
     * @param correlationKey correlation key to be assigned to process instance
     * @param body optional map of process variables
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public startProcessWithCorrelation(containerId: string, processId: string, correlationKey: string, body?: string, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public startProcessWithCorrelation(containerId: string, processId: string, correlationKey: string, body?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public startProcessWithCorrelation(containerId: string, processId: string, correlationKey: string, body?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public startProcessWithCorrelation(containerId: string, processId: string, correlationKey: string, body?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling startProcessWithCorrelation.');
        }

        if (processId === null || processId === undefined) {
            throw new Error('Required parameter processId was null or undefined when calling startProcessWithCorrelation.');
        }

        if (correlationKey === null || correlationKey === undefined) {
            throw new Error('Required parameter correlationKey was null or undefined when calling startProcessWithCorrelation.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<number>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/${encodeURIComponent(String(processId))}/instances/correlation/${encodeURIComponent(String(correlationKey))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Starts a new process instance from the specific nodes
     *
     * @param containerId container id where the process definition resides
     * @param processId process instance id that new instance should be created from
     * @param correlationKey correlation key that should be used for creating the process
     * @param body start process specifications
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public startProcessWithCorrelationKeyFromNodeIds(containerId: string, processId: string, correlationKey: string, body?: string, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public startProcessWithCorrelationKeyFromNodeIds(containerId: string, processId: string, correlationKey: string, body?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public startProcessWithCorrelationKeyFromNodeIds(containerId: string, processId: string, correlationKey: string, body?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public startProcessWithCorrelationKeyFromNodeIds(containerId: string, processId: string, correlationKey: string, body?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling startProcessWithCorrelationKeyFromNodeIds.');
        }

        if (processId === null || processId === undefined) {
            throw new Error('Required parameter processId was null or undefined when calling startProcessWithCorrelationKeyFromNodeIds.');
        }

        if (correlationKey === null || correlationKey === undefined) {
            throw new Error('Required parameter correlationKey was null or undefined when calling startProcessWithCorrelationKeyFromNodeIds.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<number>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/${encodeURIComponent(String(processId))}/instances/correlation/${encodeURIComponent(String(correlationKey))}/fromNodes`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Starts a new synchronous process instance of a specified process.
     *
     * @param containerId container id where the process definition resides
     * @param processId process id that new instance should be created from
     * @param body optional map of process variables
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public startSynchronousProcess(containerId: string, processId: string, body?: string, observe?: 'body', reportProgress?: boolean): Observable<{ [key: string]: any; }>;
    public startSynchronousProcess(containerId: string, processId: string, body?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{ [key: string]: any; }>>;
    public startSynchronousProcess(containerId: string, processId: string, body?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<{ [key: string]: any; }>>;
    public startSynchronousProcess(containerId: string, processId: string, body?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling startSynchronousProcess.');
        }

        if (processId === null || processId === undefined) {
            throw new Error('Required parameter processId was null or undefined when calling startSynchronousProcess.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<{ [key: string]: any; }>(`${this.basePath}/server/containers/${encodeURIComponent(String(containerId))}/processes/${encodeURIComponent(String(processId))}/computedInstances`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
