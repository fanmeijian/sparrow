/**
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { CountDefinition } from '../model/countDefinition';
import { NodeInstance } from '../model/nodeInstance';
import { NodeInstanceList } from '../model/nodeInstanceList';
import { ProcessDefinition } from '../model/processDefinition';
import { ProcessDefinitionList } from '../model/processDefinitionList';
import { ProcessInstance } from '../model/processInstance';
import { ProcessInstanceCustomVarsList } from '../model/processInstanceCustomVarsList';
import { ProcessInstanceList } from '../model/processInstanceList';
import { ProcessInstanceUserTaskWithVariablesList } from '../model/processInstanceUserTaskWithVariablesList';
import { TaskEventInstanceList } from '../model/taskEventInstanceList';
import { TaskInstance } from '../model/taskInstance';
import { TaskSummaryList } from '../model/taskSummaryList';
import { VariableInstanceList } from '../model/variableInstanceList';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ProcessQueriesService {

    protected basePath = 'https://localhost/bpm/rest';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Returns the count of all process instances for a specified KIE container.
     *
     * @param containerId container id to filter process instance
     * @param status optional process instance status (active, completed, aborted) - defaults ot active (1) only
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public countProcessInstancesByDeploymentId(containerId: string, status?: Array<1 | 2 | 3>, observe?: 'body', reportProgress?: boolean): Observable<CountDefinition>;
    public countProcessInstancesByDeploymentId(containerId: string, status?: Array<1 | 2 | 3>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CountDefinition>>;
    public countProcessInstancesByDeploymentId(containerId: string, status?: Array<1 | 2 | 3>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CountDefinition>>;
    public countProcessInstancesByDeploymentId(containerId: string, status?: Array<1 | 2 | 3>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling countProcessInstancesByDeploymentId.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('status', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CountDefinition>(`${this.basePath}/server/queries/containers/${encodeURIComponent(String(containerId))}/process/instances/count`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all task instances.
     *
     * @param user optional user id to be used instead of authenticated user - only when bypass authenticated user is enabled
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllAuditTask(user?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TaskSummaryList>;
    public getAllAuditTask(user?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TaskSummaryList>>;
    public getAllAuditTask(user?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TaskSummaryList>>;
    public getAllAuditTask(user?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TaskSummaryList>(`${this.basePath}/server/queries/tasks/instances`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns node instances for a specified work item in a specified process instance.
     *
     * @param processInstanceId process instance id that work item belongs to
     * @param workItemId work item id to retrieve node instance for
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getNodeInstanceForWorkItem(processInstanceId: number, workItemId: number, observe?: 'body', reportProgress?: boolean): Observable<NodeInstance>;
    public getNodeInstanceForWorkItem(processInstanceId: number, workItemId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<NodeInstance>>;
    public getNodeInstanceForWorkItem(processInstanceId: number, workItemId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<NodeInstance>>;
    public getNodeInstanceForWorkItem(processInstanceId: number, workItemId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling getNodeInstanceForWorkItem.');
        }

        if (workItemId === null || workItemId === undefined) {
            throw new Error('Required parameter workItemId was null or undefined when calling getNodeInstanceForWorkItem.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<NodeInstance>(`${this.basePath}/server/queries/processes/instances/${encodeURIComponent(String(processInstanceId))}/wi-nodes/instances/${encodeURIComponent(String(workItemId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns information about a single process instance with a specified correlation key.
     *
     * @param correlationKey correlation key associated with process instance
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessInstanceByCorrelationKey(correlationKey: string, observe?: 'body', reportProgress?: boolean): Observable<ProcessInstance>;
    public getProcessInstanceByCorrelationKey(correlationKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessInstance>>;
    public getProcessInstanceByCorrelationKey(correlationKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessInstance>>;
    public getProcessInstanceByCorrelationKey(correlationKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (correlationKey === null || correlationKey === undefined) {
            throw new Error('Required parameter correlationKey was null or undefined when calling getProcessInstanceByCorrelationKey.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ProcessInstance>(`${this.basePath}/server/queries/processes/instance/correlation/${encodeURIComponent(String(correlationKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns information about a specified process instance.
     *
     * @param processInstanceId process instance id to retrieve process instance
     * @param withVars load process instance variables or not, defaults to false
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessInstanceById(processInstanceId: number, withVars?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ProcessInstance>;
    public getProcessInstanceById(processInstanceId: number, withVars?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessInstance>>;
    public getProcessInstanceById(processInstanceId: number, withVars?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessInstance>>;
    public getProcessInstanceById(processInstanceId: number, withVars?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling getProcessInstanceById.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (withVars !== undefined && withVars !== null) {
            queryParameters = queryParameters.set('withVars', <any>withVars);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ProcessInstance>(`${this.basePath}/server/queries/processes/instances/${encodeURIComponent(String(processInstanceId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns process instances with a specified variable.
     *
     * @param varName variable name to filter process instance
     * @param varValue variable value to filter process instance, optional when filtering by name only required when filtering by name and value
     * @param status optional process instance status (active, completed, aborted) - defaults ot active (1) only
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessInstanceByVariables(varName: string, varValue?: string, status?: Array<1 | 2 | 3>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ProcessInstanceList>;
    public getProcessInstanceByVariables(varName: string, varValue?: string, status?: Array<1 | 2 | 3>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessInstanceList>>;
    public getProcessInstanceByVariables(varName: string, varValue?: string, status?: Array<1 | 2 | 3>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessInstanceList>>;
    public getProcessInstanceByVariables(varName: string, varValue?: string, status?: Array<1 | 2 | 3>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (varName === null || varName === undefined) {
            throw new Error('Required parameter varName was null or undefined when calling getProcessInstanceByVariables.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (varValue !== undefined && varValue !== null) {
            queryParameters = queryParameters.set('varValue', <any>varValue);
        }
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('status', <any>element);
            })
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ProcessInstanceList>(`${this.basePath}/server/queries/processes/instances/variables/${encodeURIComponent(String(varName))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns node instances for a specified process instance.
     *
     * @param processInstanceId process instance id to to retrive history for
     * @param activeOnly include active nodes only
     * @param completedOnly include completed nodes only
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessInstanceHistory1(processInstanceId: number, activeOnly?: boolean, completedOnly?: boolean, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<NodeInstanceList>;
    public getProcessInstanceHistory1(processInstanceId: number, activeOnly?: boolean, completedOnly?: boolean, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<NodeInstanceList>>;
    public getProcessInstanceHistory1(processInstanceId: number, activeOnly?: boolean, completedOnly?: boolean, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<NodeInstanceList>>;
    public getProcessInstanceHistory1(processInstanceId: number, activeOnly?: boolean, completedOnly?: boolean, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling getProcessInstanceHistory1.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('activeOnly', <any>activeOnly);
        }
        if (completedOnly !== undefined && completedOnly !== null) {
            queryParameters = queryParameters.set('completedOnly', <any>completedOnly);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<NodeInstanceList>(`${this.basePath}/server/queries/processes/instances/${encodeURIComponent(String(processInstanceId))}/nodes/instances`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all process instances filtered by optional parameters.
     *
     * @param status optional process instance status (active, completed, aborted) - defaults ot active (1) only
     * @param initiator optional process instance initiator - user who started process instance to filter process instances
     * @param processName optional process name to filter process instances
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessInstances1(status?: Array<1 | 2 | 3>, initiator?: string, processName?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ProcessInstanceList>;
    public getProcessInstances1(status?: Array<1 | 2 | 3>, initiator?: string, processName?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessInstanceList>>;
    public getProcessInstances1(status?: Array<1 | 2 | 3>, initiator?: string, processName?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessInstanceList>>;
    public getProcessInstances1(status?: Array<1 | 2 | 3>, initiator?: string, processName?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('status', <any>element);
            })
        }
        if (initiator !== undefined && initiator !== null) {
            queryParameters = queryParameters.set('initiator', <any>initiator);
        }
        if (processName !== undefined && processName !== null) {
            queryParameters = queryParameters.set('processName', <any>processName);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ProcessInstanceList>(`${this.basePath}/server/queries/processes/instances`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns process instances with a specified correlation key.
     *
     * @param correlationKey correlation key to filter process instance, can be given as partial correlation key like in starts with approach
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessInstancesByCorrelationKey(correlationKey: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ProcessInstanceList>;
    public getProcessInstancesByCorrelationKey(correlationKey: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessInstanceList>>;
    public getProcessInstancesByCorrelationKey(correlationKey: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessInstanceList>>;
    public getProcessInstancesByCorrelationKey(correlationKey: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (correlationKey === null || correlationKey === undefined) {
            throw new Error('Required parameter correlationKey was null or undefined when calling getProcessInstancesByCorrelationKey.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ProcessInstanceList>(`${this.basePath}/server/queries/processes/instances/correlation/${encodeURIComponent(String(correlationKey))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all process instances for a specified KIE container.
     *
     * @param containerId container id to filter process instance
     * @param status optional process instance status (active, completed, aborted) - defaults ot active (1) only
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessInstancesByDeploymentId1(containerId: string, status?: Array<1 | 2 | 3>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ProcessInstanceList>;
    public getProcessInstancesByDeploymentId1(containerId: string, status?: Array<1 | 2 | 3>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessInstanceList>>;
    public getProcessInstancesByDeploymentId1(containerId: string, status?: Array<1 | 2 | 3>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessInstanceList>>;
    public getProcessInstancesByDeploymentId1(containerId: string, status?: Array<1 | 2 | 3>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getProcessInstancesByDeploymentId1.');
        }






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('status', <any>element);
            })
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ProcessInstanceList>(`${this.basePath}/server/queries/containers/${encodeURIComponent(String(containerId))}/process/instances`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all process instances for a specified process.
     *
     * @param processId process id to filter process instance
     * @param status optional process instance status (active, completed, aborted) - defaults ot active (1) only
     * @param initiator optinal process instance initiator - user who started process instance to filtr process instances
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessInstancesByProcessId(processId: string, status?: Array<1 | 2 | 3>, initiator?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ProcessInstanceList>;
    public getProcessInstancesByProcessId(processId: string, status?: Array<1 | 2 | 3>, initiator?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessInstanceList>>;
    public getProcessInstancesByProcessId(processId: string, status?: Array<1 | 2 | 3>, initiator?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessInstanceList>>;
    public getProcessInstancesByProcessId(processId: string, status?: Array<1 | 2 | 3>, initiator?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (processId === null || processId === undefined) {
            throw new Error('Required parameter processId was null or undefined when calling getProcessInstancesByProcessId.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('status', <any>element);
            })
        }
        if (initiator !== undefined && initiator !== null) {
            queryParameters = queryParameters.set('initiator', <any>initiator);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ProcessInstanceList>(`${this.basePath}/server/queries/processes/${encodeURIComponent(String(processId))}/instances`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all process definitions in a specified KIE container.
     *
     * @param containerId container id to filter process definitions
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessesByDeploymentId1(containerId: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ProcessDefinitionList>;
    public getProcessesByDeploymentId1(containerId: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessDefinitionList>>;
    public getProcessesByDeploymentId1(containerId: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessDefinitionList>>;
    public getProcessesByDeploymentId1(containerId: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getProcessesByDeploymentId1.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ProcessDefinitionList>(`${this.basePath}/server/queries/containers/${encodeURIComponent(String(containerId))}/processes/definitions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns information about a specified process definition in a specified KIE container.
     *
     * @param containerId container id that process definition belongs to
     * @param processId process id to load process definition
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessesByDeploymentIdProcessId(containerId: string, processId: string, observe?: 'body', reportProgress?: boolean): Observable<ProcessDefinition>;
    public getProcessesByDeploymentIdProcessId(containerId: string, processId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessDefinition>>;
    public getProcessesByDeploymentIdProcessId(containerId: string, processId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessDefinition>>;
    public getProcessesByDeploymentIdProcessId(containerId: string, processId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getProcessesByDeploymentIdProcessId.');
        }

        if (processId === null || processId === undefined) {
            throw new Error('Required parameter processId was null or undefined when calling getProcessesByDeploymentIdProcessId.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ProcessDefinition>(`${this.basePath}/server/queries/containers/${encodeURIComponent(String(containerId))}/processes/definitions/${encodeURIComponent(String(processId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all process definitions.
     *
     * @param filter process id or name to filter process definitions
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessesByFilter(filter?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ProcessDefinitionList>;
    public getProcessesByFilter(filter?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessDefinitionList>>;
    public getProcessesByFilter(filter?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessDefinitionList>>;
    public getProcessesByFilter(filter?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (filter !== undefined && filter !== null) {
            queryParameters = queryParameters.set('filter', <any>filter);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ProcessDefinitionList>(`${this.basePath}/server/queries/processes/definitions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all process definitions for a specified process.
     *
     * @param processId process id to load process definition
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessesById(processId: string, observe?: 'body', reportProgress?: boolean): Observable<ProcessDefinitionList>;
    public getProcessesById(processId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessDefinitionList>>;
    public getProcessesById(processId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessDefinitionList>>;
    public getProcessesById(processId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (processId === null || processId === undefined) {
            throw new Error('Required parameter processId was null or undefined when calling getProcessesById.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ProcessDefinitionList>(`${this.basePath}/server/queries/processes/definitions/${encodeURIComponent(String(processId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns information about a specified task instance.
     *
     * @param taskInstanceId task id to load task instance
     * @param withSLA optional include SLA data - defaults to false
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTaskById(taskInstanceId: number, withSLA?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TaskInstance>;
    public getTaskById(taskInstanceId: number, withSLA?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TaskInstance>>;
    public getTaskById(taskInstanceId: number, withSLA?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TaskInstance>>;
    public getTaskById(taskInstanceId: number, withSLA?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (taskInstanceId === null || taskInstanceId === undefined) {
            throw new Error('Required parameter taskInstanceId was null or undefined when calling getTaskById.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (withSLA !== undefined && withSLA !== null) {
            queryParameters = queryParameters.set('withSLA', <any>withSLA);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TaskInstance>(`${this.basePath}/server/queries/tasks/instances/${encodeURIComponent(String(taskInstanceId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns task instances with a specified work item.
     *
     * @param workItemId work item id to load task associated with
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTaskByWorkItemId(workItemId: number, observe?: 'body', reportProgress?: boolean): Observable<TaskInstance>;
    public getTaskByWorkItemId(workItemId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TaskInstance>>;
    public getTaskByWorkItemId(workItemId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TaskInstance>>;
    public getTaskByWorkItemId(workItemId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (workItemId === null || workItemId === undefined) {
            throw new Error('Required parameter workItemId was null or undefined when calling getTaskByWorkItemId.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TaskInstance>(`${this.basePath}/server/queries/tasks/instances/workitem/${encodeURIComponent(String(workItemId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns events for a specified task instance.
     *
     * @param taskInstanceId task id to load task events for
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTaskEvents(taskInstanceId: number, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TaskEventInstanceList>;
    public getTaskEvents(taskInstanceId: number, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TaskEventInstanceList>>;
    public getTaskEvents(taskInstanceId: number, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TaskEventInstanceList>>;
    public getTaskEvents(taskInstanceId: number, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (taskInstanceId === null || taskInstanceId === undefined) {
            throw new Error('Required parameter taskInstanceId was null or undefined when calling getTaskEvents.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TaskEventInstanceList>(`${this.basePath}/server/queries/tasks/instances/${encodeURIComponent(String(taskInstanceId))}/events`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns task instances assigned to business administrators.
     *
     * @param status optional task status (Created, Ready, Reserved, InProgress, Suspended, Completed, Failed, Error, Exited, Obsolete)
     * @param user optional user id to be used instead of authenticated user - only when bypass authenticated user is enabled
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTasksAssignedAsBusinessAdministratorByStatus(status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, user?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TaskSummaryList>;
    public getTasksAssignedAsBusinessAdministratorByStatus(status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, user?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TaskSummaryList>>;
    public getTasksAssignedAsBusinessAdministratorByStatus(status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, user?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TaskSummaryList>>;
    public getTasksAssignedAsBusinessAdministratorByStatus(status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, user?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('status', <any>element);
            })
        }
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TaskSummaryList>(`${this.basePath}/server/queries/tasks/instances/admins`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns tasks with a user defined as a potential owner.
     *
     * @param status optional task status (Created, Ready, Reserved, InProgress, Suspended, Completed, Failed, Error, Exited, Obsolete)
     * @param groups optional group names to include in the query
     * @param user optional user id to be used instead of authenticated user - only when bypass authenticated user is enabled
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param filter optional custom filter for task data
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTasksAssignedAsPotentialOwner(status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, groups?: Array<string>, user?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, filter?: string, observe?: 'body', reportProgress?: boolean): Observable<TaskSummaryList>;
    public getTasksAssignedAsPotentialOwner(status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, groups?: Array<string>, user?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, filter?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TaskSummaryList>>;
    public getTasksAssignedAsPotentialOwner(status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, groups?: Array<string>, user?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, filter?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TaskSummaryList>>;
    public getTasksAssignedAsPotentialOwner(status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, groups?: Array<string>, user?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, filter?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {









        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('status', <any>element);
            })
        }
        if (groups) {
            groups.forEach((element) => {
                queryParameters = queryParameters.append('groups', <any>element);
            })
        }
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }
        if (filter !== undefined && filter !== null) {
            queryParameters = queryParameters.set('filter', <any>filter);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TaskSummaryList>(`${this.basePath}/server/queries/tasks/instances/pot-owners`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns task instances associated with a specified process instance.
     *
     * @param processInstanceId process instance id to filter task instances
     * @param status optional task status (Created, Ready, Reserved, InProgress, Suspended, Completed, Failed, Error, Exited, Obsolete)
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTasksByStatusByProcessInstanceId(processInstanceId: number, status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TaskSummaryList>;
    public getTasksByStatusByProcessInstanceId(processInstanceId: number, status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TaskSummaryList>>;
    public getTasksByStatusByProcessInstanceId(processInstanceId: number, status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TaskSummaryList>>;
    public getTasksByStatusByProcessInstanceId(processInstanceId: number, status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling getTasksByStatusByProcessInstanceId.');
        }






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('status', <any>element);
            })
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TaskSummaryList>(`${this.basePath}/server/queries/tasks/instances/process/${encodeURIComponent(String(processInstanceId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns task instances with a specified variable.
     *
     * @param varName name of the variable used to fiter tasks
     * @param varValue value of the variable used to fiter tasks, optional when filtering only by name, required when filtering by both name and value
     * @param status optional task status (Created, Ready, Reserved, InProgress, Suspended, Completed, Failed, Error, Exited, Obsolete)
     * @param user optional user id to be used instead of authenticated user - only when bypass authenticated user is enabled
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTasksByVariables(varName: string, varValue?: string, status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, user?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TaskSummaryList>;
    public getTasksByVariables(varName: string, varValue?: string, status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, user?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TaskSummaryList>>;
    public getTasksByVariables(varName: string, varValue?: string, status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, user?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TaskSummaryList>>;
    public getTasksByVariables(varName: string, varValue?: string, status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, user?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (varName === null || varName === undefined) {
            throw new Error('Required parameter varName was null or undefined when calling getTasksByVariables.');
        }








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (varValue !== undefined && varValue !== null) {
            queryParameters = queryParameters.set('varValue', <any>varValue);
        }
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('status', <any>element);
            })
        }
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TaskSummaryList>(`${this.basePath}/server/queries/tasks/instances/variables/${encodeURIComponent(String(varName))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns task instances that the querying user owns.
     *
     * @param status optional task status (Created, Ready, Reserved, InProgress, Suspended, Completed, Failed, Error, Exited, Obsolete)
     * @param user optional user id to be used instead of authenticated user - only when bypass authenticated user is enabled
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTasksOwnedByStatus(status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, user?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TaskSummaryList>;
    public getTasksOwnedByStatus(status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, user?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TaskSummaryList>>;
    public getTasksOwnedByStatus(status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, user?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TaskSummaryList>>;
    public getTasksOwnedByStatus(status?: Array<'Created' | 'Ready' | 'Reserved' | 'InProgress' | 'Suspended' | 'Completed' | 'Failed' | 'Error' | 'Exited' | 'Obsolete'>, user?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (status) {
            status.forEach((element) => {
                queryParameters = queryParameters.append('status', <any>element);
            })
        }
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TaskSummaryList>(`${this.basePath}/server/queries/tasks/instances/owners`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns the history of a specified variable in a specified process instance.
     *
     * @param processInstanceId process instance id to load variable history for
     * @param varName variable name that history should be loaded for
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getVariableHistory1(processInstanceId: number, varName: string, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<VariableInstanceList>;
    public getVariableHistory1(processInstanceId: number, varName: string, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<VariableInstanceList>>;
    public getVariableHistory1(processInstanceId: number, varName: string, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<VariableInstanceList>>;
    public getVariableHistory1(processInstanceId: number, varName: string, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling getVariableHistory1.');
        }

        if (varName === null || varName === undefined) {
            throw new Error('Required parameter varName was null or undefined when calling getVariableHistory1.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<VariableInstanceList>(`${this.basePath}/server/queries/processes/instances/${encodeURIComponent(String(processInstanceId))}/variables/instances/${encodeURIComponent(String(varName))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns current variable values of a specified process instance.
     *
     * @param processInstanceId process instance id to load variables current state (latest value) for
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getVariablesCurrentState1(processInstanceId: number, observe?: 'body', reportProgress?: boolean): Observable<VariableInstanceList>;
    public getVariablesCurrentState1(processInstanceId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<VariableInstanceList>>;
    public getVariablesCurrentState1(processInstanceId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<VariableInstanceList>>;
    public getVariablesCurrentState1(processInstanceId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (processInstanceId === null || processInstanceId === undefined) {
            throw new Error('Required parameter processInstanceId was null or undefined when calling getVariablesCurrentState1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<VariableInstanceList>(`${this.basePath}/server/queries/processes/instances/${encodeURIComponent(String(processInstanceId))}/variables/instances`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Queries processes by variables and tasks
     *
     * @param body
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param orderBy optional sort column
     * @param asc optional sort direction - true ascending, false descending
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public queryProcessesByVariables(body?: string, page?: number, pageSize?: number, orderBy?: string, asc?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ProcessInstanceCustomVarsList>;
    public queryProcessesByVariables(body?: string, page?: number, pageSize?: number, orderBy?: string, asc?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessInstanceCustomVarsList>>;
    public queryProcessesByVariables(body?: string, page?: number, pageSize?: number, orderBy?: string, asc?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessInstanceCustomVarsList>>;
    public queryProcessesByVariables(body?: string, page?: number, pageSize?: number, orderBy?: string, asc?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', <any>orderBy);
        }
        if (asc !== undefined && asc !== null) {
            queryParameters = queryParameters.set('asc', <any>asc);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ProcessInstanceCustomVarsList>(`${this.basePath}/server/queries/variables/processes`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Queries process tasks by variables
     *
     * @param body
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param orderBy optional sort column
     * @param asc optional sort direction - true ascending, false descending
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public queryUserTasksByVariables(body?: string, page?: number, pageSize?: number, orderBy?: string, asc?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ProcessInstanceUserTaskWithVariablesList>;
    public queryUserTasksByVariables(body?: string, page?: number, pageSize?: number, orderBy?: string, asc?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProcessInstanceUserTaskWithVariablesList>>;
    public queryUserTasksByVariables(body?: string, page?: number, pageSize?: number, orderBy?: string, asc?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProcessInstanceUserTaskWithVariablesList>>;
    public queryUserTasksByVariables(body?: string, page?: number, pageSize?: number, orderBy?: string, asc?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = queryParameters.set('orderBy', <any>orderBy);
        }
        if (asc !== undefined && asc !== null) {
            queryParameters = queryParameters.set('asc', <any>asc);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ProcessInstanceUserTaskWithVariablesList>(`${this.basePath}/server/queries/variables/processes/tasks`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
