/**
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { ExecutionErrorInstance } from '../model/executionErrorInstance';
import { ExecutionErrorInstanceList } from '../model/executionErrorInstanceList';
import { TaskNotificationList } from '../model/taskNotificationList';
import { TaskReassignmentList } from '../model/taskReassignmentList';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class TaskInstanceAdministrationService {

    protected basePath = 'https://localhost/bpm/rest';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Acknowledges a specified task execution error.
     *
     * @param containerId container id that error belongs to
     * @param errorId identifier of the execution error to be acknowledged
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public acknowledgeError1(containerId: string, errorId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public acknowledgeError1(containerId: string, errorId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public acknowledgeError1(containerId: string, errorId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public acknowledgeError1(containerId: string, errorId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling acknowledgeError1.');
        }

        if (errorId === null || errorId === undefined) {
            throw new Error('Required parameter errorId was null or undefined when calling acknowledgeError1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.put<any>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/errors/${encodeURIComponent(String(errorId))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Acknowledges one or more task execution errors in a specified KIE container.
     *
     * @param containerId container id that errors belong to
     * @param errorId list of identifiers of execution errors to be acknowledged
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public acknowledgeErrors1(containerId: string, errorId: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public acknowledgeErrors1(containerId: string, errorId: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public acknowledgeErrors1(containerId: string, errorId: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public acknowledgeErrors1(containerId: string, errorId: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling acknowledgeErrors1.');
        }

        if (errorId === null || errorId === undefined) {
            throw new Error('Required parameter errorId was null or undefined when calling acknowledgeErrors1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (errorId) {
            errorId.forEach((element) => {
                queryParameters = queryParameters.append('errorId', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.put<any>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/errors`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Adds business administrator users or groups to a specified task instance.
     *
     * @param containerId container id that task instance belongs to
     * @param taskInstanceId identifier of task instance to be updated
     * @param body list of users/groups to be added as business admins, as OrgEntities type
     * @param user optional user id to be used instead of authenticated user - only when bypass authenticated user is enabled
     * @param remove optional flag that indicates if existing business admins should be removed, defaults to false
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addAdmins(containerId: string, taskInstanceId: number, body: string, user?: string, remove?: boolean, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public addAdmins(containerId: string, taskInstanceId: number, body: string, user?: string, remove?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public addAdmins(containerId: string, taskInstanceId: number, body: string, user?: string, remove?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public addAdmins(containerId: string, taskInstanceId: number, body: string, user?: string, remove?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling addAdmins.');
        }

        if (taskInstanceId === null || taskInstanceId === undefined) {
            throw new Error('Required parameter taskInstanceId was null or undefined when calling addAdmins.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addAdmins.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }
        if (remove !== undefined && remove !== null) {
            queryParameters = queryParameters.set('remove', <any>remove);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/${encodeURIComponent(String(taskInstanceId))}/admins`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Adds users and groups to be excluded from being owners for a specified task instance.
     *
     * @param containerId container id that task instance belongs to
     * @param taskInstanceId identifier of task instance to be updated
     * @param body list of users/groups to be added as excluded owners, as OrgEntities type
     * @param user optional user id to be used instead of authenticated user - only when bypass authenticated user is enabled
     * @param remove optional flag that indicates if existing excluded owners should be removed, defaults to false
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addExcludedOwners(containerId: string, taskInstanceId: number, body: string, user?: string, remove?: boolean, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public addExcludedOwners(containerId: string, taskInstanceId: number, body: string, user?: string, remove?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public addExcludedOwners(containerId: string, taskInstanceId: number, body: string, user?: string, remove?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public addExcludedOwners(containerId: string, taskInstanceId: number, body: string, user?: string, remove?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling addExcludedOwners.');
        }

        if (taskInstanceId === null || taskInstanceId === undefined) {
            throw new Error('Required parameter taskInstanceId was null or undefined when calling addExcludedOwners.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addExcludedOwners.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }
        if (remove !== undefined && remove !== null) {
            queryParameters = queryParameters.set('remove', <any>remove);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/${encodeURIComponent(String(taskInstanceId))}/exl-owners`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Adds users and groups as potential owners to a specified task instance.
     *
     * @param containerId container id that task instance belongs to
     * @param taskInstanceId identifier of task instance to be updated
     * @param body list of users/groups to be added as potential owners, as OrgEntities type
     * @param user optional user id to be used instead of authenticated user - only when bypass authenticated user is enabled
     * @param remove optional flag that indicates if existing potential owners should be removed, defaults to false
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addPotentialOwners(containerId: string, taskInstanceId: number, body: string, user?: string, remove?: boolean, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public addPotentialOwners(containerId: string, taskInstanceId: number, body: string, user?: string, remove?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public addPotentialOwners(containerId: string, taskInstanceId: number, body: string, user?: string, remove?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public addPotentialOwners(containerId: string, taskInstanceId: number, body: string, user?: string, remove?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling addPotentialOwners.');
        }

        if (taskInstanceId === null || taskInstanceId === undefined) {
            throw new Error('Required parameter taskInstanceId was null or undefined when calling addPotentialOwners.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addPotentialOwners.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }
        if (remove !== undefined && remove !== null) {
            queryParameters = queryParameters.set('remove', <any>remove);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/${encodeURIComponent(String(taskInstanceId))}/pot-owners`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Adds input data to a specified task instance.
     *
     * @param containerId container id that task instance belongs to
     * @param taskInstanceId identifier of task instance to be updated
     * @param body map of data to be set as task inputs, as Map
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addTaskInputs(containerId: string, taskInstanceId: number, body: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public addTaskInputs(containerId: string, taskInstanceId: number, body: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public addTaskInputs(containerId: string, taskInstanceId: number, body: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public addTaskInputs(containerId: string, taskInstanceId: number, body: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling addTaskInputs.');
        }

        if (taskInstanceId === null || taskInstanceId === undefined) {
            throw new Error('Required parameter taskInstanceId was null or undefined when calling addTaskInputs.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addTaskInputs.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/${encodeURIComponent(String(taskInstanceId))}/contents/input`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specified email notification from a specified task instance.
     *
     * @param containerId container id that task instance belongs to
     * @param taskInstanceId identifier of task instance to be updated
     * @param notificationId identifier of notification to be canceled
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cancelNotification(containerId: string, taskInstanceId: number, notificationId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public cancelNotification(containerId: string, taskInstanceId: number, notificationId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public cancelNotification(containerId: string, taskInstanceId: number, notificationId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public cancelNotification(containerId: string, taskInstanceId: number, notificationId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling cancelNotification.');
        }

        if (taskInstanceId === null || taskInstanceId === undefined) {
            throw new Error('Required parameter taskInstanceId was null or undefined when calling cancelNotification.');
        }

        if (notificationId === null || notificationId === undefined) {
            throw new Error('Required parameter notificationId was null or undefined when calling cancelNotification.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/${encodeURIComponent(String(taskInstanceId))}/notifications/${encodeURIComponent(String(notificationId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specified reassignment for a specified task instance.
     *
     * @param containerId container id that task instance belongs to
     * @param taskInstanceId identifier of task instance to be updated
     * @param reassignmentId identifier of reassignment to be canceled
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cancelReassignment(containerId: string, taskInstanceId: number, reassignmentId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public cancelReassignment(containerId: string, taskInstanceId: number, reassignmentId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public cancelReassignment(containerId: string, taskInstanceId: number, reassignmentId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public cancelReassignment(containerId: string, taskInstanceId: number, reassignmentId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling cancelReassignment.');
        }

        if (taskInstanceId === null || taskInstanceId === undefined) {
            throw new Error('Required parameter taskInstanceId was null or undefined when calling cancelReassignment.');
        }

        if (reassignmentId === null || reassignmentId === undefined) {
            throw new Error('Required parameter reassignmentId was null or undefined when calling cancelReassignment.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/${encodeURIComponent(String(taskInstanceId))}/reassignments/${encodeURIComponent(String(reassignmentId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns information about a specified task execution error.
     *
     * @param containerId container id that error belongs to
     * @param errorId identifier of the execution error to load
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getExecutionErrorById1(containerId: string, errorId: string, observe?: 'body', reportProgress?: boolean): Observable<ExecutionErrorInstance>;
    public getExecutionErrorById1(containerId: string, errorId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ExecutionErrorInstance>>;
    public getExecutionErrorById1(containerId: string, errorId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ExecutionErrorInstance>>;
    public getExecutionErrorById1(containerId: string, errorId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getExecutionErrorById1.');
        }

        if (errorId === null || errorId === undefined) {
            throw new Error('Required parameter errorId was null or undefined when calling getExecutionErrorById1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ExecutionErrorInstance>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/errors/${encodeURIComponent(String(errorId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all task execution errors for a specified KIE container.
     *
     * @param containerId container id that task instance belongs to
     * @param includeAck optional flag that indicates if acknowledged errors should also be collected, defaults to false
     * @param name optional name of the task to filter by
     * @param process optional process id that the task belongs to to filter by
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getExecutionErrors1(containerId: string, includeAck?: boolean, name?: string, process?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ExecutionErrorInstanceList>;
    public getExecutionErrors1(containerId: string, includeAck?: boolean, name?: string, process?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ExecutionErrorInstanceList>>;
    public getExecutionErrors1(containerId: string, includeAck?: boolean, name?: string, process?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ExecutionErrorInstanceList>>;
    public getExecutionErrors1(containerId: string, includeAck?: boolean, name?: string, process?: string, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getExecutionErrors1.');
        }








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (includeAck !== undefined && includeAck !== null) {
            queryParameters = queryParameters.set('includeAck', <any>includeAck);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (process !== undefined && process !== null) {
            queryParameters = queryParameters.set('process', <any>process);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ExecutionErrorInstanceList>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/errors`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns task execution errors for a specified task instance.
     *
     * @param containerId container id that task instance belongs to
     * @param taskInstanceId identifier of the task instance that errors should be collected for
     * @param includeAck optional flag that indicates if acknowledged errors should also be collected, defaults to false
     * @param page optional pagination - at which page to start, defaults to 0 (meaning first)
     * @param pageSize optional pagination - size of the result, defaults to 10
     * @param sort optional sort column, no default
     * @param sortOrder optional sort direction (asc, desc) - defaults to asc
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getExecutionErrorsByTask(containerId: string, taskInstanceId: number, includeAck?: boolean, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ExecutionErrorInstanceList>;
    public getExecutionErrorsByTask(containerId: string, taskInstanceId: number, includeAck?: boolean, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ExecutionErrorInstanceList>>;
    public getExecutionErrorsByTask(containerId: string, taskInstanceId: number, includeAck?: boolean, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ExecutionErrorInstanceList>>;
    public getExecutionErrorsByTask(containerId: string, taskInstanceId: number, includeAck?: boolean, page?: number, pageSize?: number, sort?: string, sortOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getExecutionErrorsByTask.');
        }

        if (taskInstanceId === null || taskInstanceId === undefined) {
            throw new Error('Required parameter taskInstanceId was null or undefined when calling getExecutionErrorsByTask.');
        }






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (includeAck !== undefined && includeAck !== null) {
            queryParameters = queryParameters.set('includeAck', <any>includeAck);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortOrder !== undefined && sortOrder !== null) {
            queryParameters = queryParameters.set('sortOrder', <any>sortOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ExecutionErrorInstanceList>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/${encodeURIComponent(String(taskInstanceId))}/errors`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns notifications created for a specified task instance.
     *
     * @param containerId container id that task instance belongs to
     * @param taskInstanceId identifier of task instance to be updated
     * @param activeOnly optional flag that indicates if active only notifications should be collected, defaults to true
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTaskNotifications(containerId: string, taskInstanceId: number, activeOnly?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TaskNotificationList>;
    public getTaskNotifications(containerId: string, taskInstanceId: number, activeOnly?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TaskNotificationList>>;
    public getTaskNotifications(containerId: string, taskInstanceId: number, activeOnly?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TaskNotificationList>>;
    public getTaskNotifications(containerId: string, taskInstanceId: number, activeOnly?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getTaskNotifications.');
        }

        if (taskInstanceId === null || taskInstanceId === undefined) {
            throw new Error('Required parameter taskInstanceId was null or undefined when calling getTaskNotifications.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('activeOnly', <any>activeOnly);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TaskNotificationList>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/${encodeURIComponent(String(taskInstanceId))}/notifications`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns task reassignments for a specified task instance.
     *
     * @param containerId container id that task instance belongs to
     * @param taskInstanceId identifier of task instance to be updated
     * @param activeOnly optional flag that indicates if active only reassignmnets should be collected, defaults to true
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTaskReassignments(containerId: string, taskInstanceId: number, activeOnly?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TaskReassignmentList>;
    public getTaskReassignments(containerId: string, taskInstanceId: number, activeOnly?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TaskReassignmentList>>;
    public getTaskReassignments(containerId: string, taskInstanceId: number, activeOnly?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TaskReassignmentList>>;
    public getTaskReassignments(containerId: string, taskInstanceId: number, activeOnly?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getTaskReassignments.');
        }

        if (taskInstanceId === null || taskInstanceId === undefined) {
            throw new Error('Required parameter taskInstanceId was null or undefined when calling getTaskReassignments.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('activeOnly', <any>activeOnly);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TaskReassignmentList>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/${encodeURIComponent(String(taskInstanceId))}/reassignments`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates an email notification for the specified task instance and returns the ID of the new notification.
     *
     * @param containerId container id that task instance belongs to
     * @param taskInstanceId identifier of task instance to be updated
     * @param expiresAt time expression for notification
     * @param body email notification details, as EmailNotification type
     * @param whenNotStarted optional flag that indicates the type of notification, either whenNotStarted or whenNotCompleted must be set
     * @param whenNotCompleted optional flag that indicates the type of notification, either whenNotStarted or whenNotCompleted must be set
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public notify(containerId: string, taskInstanceId: number, expiresAt: string, body: string, whenNotStarted?: boolean, whenNotCompleted?: boolean, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public notify(containerId: string, taskInstanceId: number, expiresAt: string, body: string, whenNotStarted?: boolean, whenNotCompleted?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public notify(containerId: string, taskInstanceId: number, expiresAt: string, body: string, whenNotStarted?: boolean, whenNotCompleted?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public notify(containerId: string, taskInstanceId: number, expiresAt: string, body: string, whenNotStarted?: boolean, whenNotCompleted?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling notify.');
        }

        if (taskInstanceId === null || taskInstanceId === undefined) {
            throw new Error('Required parameter taskInstanceId was null or undefined when calling notify.');
        }

        if (expiresAt === null || expiresAt === undefined) {
            throw new Error('Required parameter expiresAt was null or undefined when calling notify.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling notify.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (expiresAt !== undefined && expiresAt !== null) {
            queryParameters = queryParameters.set('expiresAt', <any>expiresAt);
        }
        if (whenNotStarted !== undefined && whenNotStarted !== null) {
            queryParameters = queryParameters.set('whenNotStarted', <any>whenNotStarted);
        }
        if (whenNotCompleted !== undefined && whenNotCompleted !== null) {
            queryParameters = queryParameters.set('whenNotCompleted', <any>whenNotCompleted);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<number>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/${encodeURIComponent(String(taskInstanceId))}/notifications`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Schedules a specified task instance to be reassigned to specified users or groups and returns the ID of the reassignment.
     *
     * @param containerId container id that task instance belongs to
     * @param taskInstanceId identifier of task instance to be updated
     * @param expiresAt time expression for reassignmnet
     * @param body list of users/groups that task should be reassined to, as OrgEntities type
     * @param whenNotStarted optional flag that indicates the type of reassignment, either whenNotStarted or whenNotCompleted must be set
     * @param whenNotCompleted optional flag that indicates the type of reassignment, either whenNotStarted or whenNotCompleted must be set
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public reassign(containerId: string, taskInstanceId: number, expiresAt: string, body: string, whenNotStarted?: boolean, whenNotCompleted?: boolean, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public reassign(containerId: string, taskInstanceId: number, expiresAt: string, body: string, whenNotStarted?: boolean, whenNotCompleted?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public reassign(containerId: string, taskInstanceId: number, expiresAt: string, body: string, whenNotStarted?: boolean, whenNotCompleted?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public reassign(containerId: string, taskInstanceId: number, expiresAt: string, body: string, whenNotStarted?: boolean, whenNotCompleted?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling reassign.');
        }

        if (taskInstanceId === null || taskInstanceId === undefined) {
            throw new Error('Required parameter taskInstanceId was null or undefined when calling reassign.');
        }

        if (expiresAt === null || expiresAt === undefined) {
            throw new Error('Required parameter expiresAt was null or undefined when calling reassign.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reassign.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (expiresAt !== undefined && expiresAt !== null) {
            queryParameters = queryParameters.set('expiresAt', <any>expiresAt);
        }
        if (whenNotStarted !== undefined && whenNotStarted !== null) {
            queryParameters = queryParameters.set('whenNotStarted', <any>whenNotStarted);
        }
        if (whenNotCompleted !== undefined && whenNotCompleted !== null) {
            queryParameters = queryParameters.set('whenNotCompleted', <any>whenNotCompleted);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<number>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/${encodeURIComponent(String(taskInstanceId))}/reassignments`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes specified groups previously added as business administrators for a specified task instance.
     *
     * @param containerId container id that task instance belongs to
     * @param taskInstanceId identifier of task instance to be updated
     * @param entityId list of groups to be removed from business admin list
     * @param user optional user id to be used instead of authenticated user - only when bypass authenticated user is enabled
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeAdminsGroups(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removeAdminsGroups(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removeAdminsGroups(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removeAdminsGroups(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling removeAdminsGroups.');
        }

        if (taskInstanceId === null || taskInstanceId === undefined) {
            throw new Error('Required parameter taskInstanceId was null or undefined when calling removeAdminsGroups.');
        }

        if (entityId === null || entityId === undefined) {
            throw new Error('Required parameter entityId was null or undefined when calling removeAdminsGroups.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/${encodeURIComponent(String(taskInstanceId))}/admins/groups/${encodeURIComponent(String(entityId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes specified users previously added as business administrators for a specified task instance.
     *
     * @param containerId container id that task instance belongs to
     * @param taskInstanceId identifier of task instance to be updated
     * @param entityId list of users to be removed from business admin list
     * @param user optional user id to be used instead of authenticated user - only when bypass authenticated user is enabled
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeAdminsUsers(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removeAdminsUsers(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removeAdminsUsers(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removeAdminsUsers(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling removeAdminsUsers.');
        }

        if (taskInstanceId === null || taskInstanceId === undefined) {
            throw new Error('Required parameter taskInstanceId was null or undefined when calling removeAdminsUsers.');
        }

        if (entityId === null || entityId === undefined) {
            throw new Error('Required parameter entityId was null or undefined when calling removeAdminsUsers.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/${encodeURIComponent(String(taskInstanceId))}/admins/users/${encodeURIComponent(String(entityId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes specified groups previously added as excluded owners for a specified task instance.
     *
     * @param containerId container id that task instance belongs to
     * @param taskInstanceId identifier of task instance to be updated
     * @param entityId list of groups to be removed from excluded owners list
     * @param user optional user id to be used instead of authenticated user - only when bypass authenticated user is enabled
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeExcludedOwnersGroups(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removeExcludedOwnersGroups(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removeExcludedOwnersGroups(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removeExcludedOwnersGroups(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling removeExcludedOwnersGroups.');
        }

        if (taskInstanceId === null || taskInstanceId === undefined) {
            throw new Error('Required parameter taskInstanceId was null or undefined when calling removeExcludedOwnersGroups.');
        }

        if (entityId === null || entityId === undefined) {
            throw new Error('Required parameter entityId was null or undefined when calling removeExcludedOwnersGroups.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/${encodeURIComponent(String(taskInstanceId))}/exl-owners/groups/${encodeURIComponent(String(entityId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes specified users previously added as excluded owners for a specified task instance.
     *
     * @param containerId container id that task instance belongs to
     * @param taskInstanceId identifier of task instance to be updated
     * @param entityId list of users to be removed from excluded owners list
     * @param user optional user id to be used instead of authenticated user - only when bypass authenticated user is enabled
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeExcludedOwnersUsers(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removeExcludedOwnersUsers(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removeExcludedOwnersUsers(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removeExcludedOwnersUsers(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling removeExcludedOwnersUsers.');
        }

        if (taskInstanceId === null || taskInstanceId === undefined) {
            throw new Error('Required parameter taskInstanceId was null or undefined when calling removeExcludedOwnersUsers.');
        }

        if (entityId === null || entityId === undefined) {
            throw new Error('Required parameter entityId was null or undefined when calling removeExcludedOwnersUsers.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/${encodeURIComponent(String(taskInstanceId))}/exl-owners/users/${encodeURIComponent(String(entityId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes specified groups previously added as potential owners for a specified task instance.
     *
     * @param containerId container id that task instance belongs to
     * @param taskInstanceId identifier of task instance to be updated
     * @param entityId list of groups to be removed from potantial owners list
     * @param user optional user id to be used instead of authenticated user - only when bypass authenticated user is enabled
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removePotentialOwnersGroups(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removePotentialOwnersGroups(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removePotentialOwnersGroups(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removePotentialOwnersGroups(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling removePotentialOwnersGroups.');
        }

        if (taskInstanceId === null || taskInstanceId === undefined) {
            throw new Error('Required parameter taskInstanceId was null or undefined when calling removePotentialOwnersGroups.');
        }

        if (entityId === null || entityId === undefined) {
            throw new Error('Required parameter entityId was null or undefined when calling removePotentialOwnersGroups.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/${encodeURIComponent(String(taskInstanceId))}/pot-owners/groups/${encodeURIComponent(String(entityId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes specified users previously added as potential owners for a specified task instance.
     *
     * @param containerId container id that task instance belongs to
     * @param taskInstanceId identifier of task instance to be updated
     * @param entityId list of users to be removed from potantial owners list
     * @param user optional user id to be used instead of authenticated user - only when bypass authenticated user is enabled
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removePotentialOwnersUsers(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removePotentialOwnersUsers(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removePotentialOwnersUsers(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removePotentialOwnersUsers(containerId: string, taskInstanceId: number, entityId: string, user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling removePotentialOwnersUsers.');
        }

        if (taskInstanceId === null || taskInstanceId === undefined) {
            throw new Error('Required parameter taskInstanceId was null or undefined when calling removePotentialOwnersUsers.');
        }

        if (entityId === null || entityId === undefined) {
            throw new Error('Required parameter entityId was null or undefined when calling removePotentialOwnersUsers.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/${encodeURIComponent(String(taskInstanceId))}/pot-owners/users/${encodeURIComponent(String(entityId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes input data by parameter name from a specified task instance.
     *
     * @param containerId container id that task instance belongs to
     * @param taskInstanceId identifier of task instance to be updated
     * @param name one or more names of task inputs to be removed
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeTaskInputs(containerId: string, taskInstanceId: number, name: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removeTaskInputs(containerId: string, taskInstanceId: number, name: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removeTaskInputs(containerId: string, taskInstanceId: number, name: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removeTaskInputs(containerId: string, taskInstanceId: number, name: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling removeTaskInputs.');
        }

        if (taskInstanceId === null || taskInstanceId === undefined) {
            throw new Error('Required parameter taskInstanceId was null or undefined when calling removeTaskInputs.');
        }

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling removeTaskInputs.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (name) {
            name.forEach((element) => {
                queryParameters = queryParameters.append('name', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/${encodeURIComponent(String(taskInstanceId))}/contents/input`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes output data by parameter name from a specified task instance.
     *
     * @param containerId container id that task instance belongs to
     * @param taskInstanceId identifier of task instance to be updated
     * @param name one or more names of task outputs to be removed
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeTaskOutputs(containerId: string, taskInstanceId: number, name: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removeTaskOutputs(containerId: string, taskInstanceId: number, name: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removeTaskOutputs(containerId: string, taskInstanceId: number, name: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removeTaskOutputs(containerId: string, taskInstanceId: number, name: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling removeTaskOutputs.');
        }

        if (taskInstanceId === null || taskInstanceId === undefined) {
            throw new Error('Required parameter taskInstanceId was null or undefined when calling removeTaskOutputs.');
        }

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling removeTaskOutputs.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (name) {
            name.forEach((element) => {
                queryParameters = queryParameters.append('name', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/server/admin/containers/${encodeURIComponent(String(containerId))}/tasks/${encodeURIComponent(String(taskInstanceId))}/contents/output`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
